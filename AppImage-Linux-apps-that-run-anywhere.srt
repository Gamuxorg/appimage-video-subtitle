1
00:00:00,380 --> 00:00:01,125
AppImage中文社区制作 感谢收看！

2
00:00:01,125 --> 00:00:03,200
本篇介绍AppImage

3
00:00:03,200 --> 00:00:06,000
它由Simon Peter开发 能使Linux应用随处运行

4
00:00:08,275 --> 00:00:12,059
AppImage是一种用于分发上游提供

5
00:00:12,059 --> 00:00:13,488
的应用二进制文件的格式

6
00:00:14,150 --> 00:00:17,100
这让用户可以轻松地获取和运行

7
00:00:17,100 --> 00:00:20,350
最新版本的Linux应用程序

8
00:00:21,050 --> 00:00:23,025
甚至那些只包含stable软件的系统都能运行
（例如Debian Stable和CentOS）

9
00:00:23,025 --> 00:00:25,425
这意味着软件包不会以任何形式

10
00:00:25,425 --> 00:00:30,275
干扰基础系统所安装的依赖库

11
00:00:30,275 --> 00:00:33,510
换句话说 当你下载一个AppImage文件后

12
00:00:33,510 --> 00:00:35,768
它不会影响你的基础系统

13
00:00:36,525 --> 00:00:40,650
也使得上游软件开发方为Linux提供

14
00:00:40,650 --> 00:00:44,640
正式版和每日构建版或连续构建版变得很容易

15
00:00:44,950 --> 00:00:49,150
就像以前他们倾向于为mac OS和Windows提供这些

16
00:00:49,150 --> 00:00:51,606
但很多时候不为Linux提供

17
00:00:51,814 --> 00:00:54,875
现在有了AppImage 实现起来就很容易了

18
00:00:55,350 --> 00:01:01,725
并且我认为通过我所说的软件开发流水线化可加快测试速度

19
00:01:02,065 --> 00:01:06,225
这让发布、下载、测试和制作都变得非常方便

20
00:01:06,500 --> 00:01:09,200
也让制作周期变得更短

21
00:01:10,075 --> 00:01:13,375
并且AppImage不需要任何中间机构

22
00:01:13,850 --> 00:01:17,310
如果用软件源这类

23
00:01:17,310 --> 00:01:24,450
你还得考虑的是如何把你的开源软件弄进软件源

24
00:01:24,725 --> 00:01:29,970
现在你可以为你的最终用户直接提供你的应用

25
00:01:29,970 --> 00:01:34,275
你和你最终用户之间的没有任何第三方

26
00:01:37,000 --> 00:01:39,350
简单自我介绍一下 我是Simon

27
00:01:39,350 --> 00:01:43,098
我是一名OS X和Linux live系统用户

28
00:01:43,625 --> 00:01:47,075
我不是一个真正的应用程序开发人员

29
00:01:47,075 --> 00:01:51,000
但我已经跨界写代码超过十年了

30
00:01:51,000 --> 00:01:52,900
我从一个小的UI项目开始

31
00:01:52,900 --> 00:01:55,125
它涉及到便携式Linux应用程序

32
00:01:55,675 --> 00:01:57,975
后来终于开始做AppImage

33
00:02:00,225 --> 00:02:03,475
以前来自社区的反馈不太好

34
00:02:03,475 --> 00:02:05,875
所以我曾经几乎放弃这个想法

35
00:02:05,875 --> 00:02:08,024
但我终于超越了自己

36
00:02:08,025 --> 00:02:11,734
视频后面我回过头来还要再谈这点

37
00:02:12,950 --> 00:02:15,575
现在让我们来阐述一个问题

38
00:02:15,963 --> 00:02:20,050
那就是今天我们打包和分发

39
00:02:20,050 --> 00:02:23,450
Linux应用的方式并不方便

40
00:02:24,600 --> 00:02:26,875
所以让我们开始吧

41
00:02:29,300 --> 00:02:35,150
作为一个用户，我想从原始作者那里下载一个应用程序

42
00:02:35,615 --> 00:02:38,650
并且在软件发布已发布我就想让它在Linux上运行

43
00:02:39,075 --> 00:02:42,750
就像Windows或Mac应用程序一样简单

44
00:02:43,375 --> 00:02:45,875
但目前对于Linux应用程序来说

45
00:02:46,550 --> 00:02:50,575
想做到这一点并不容易 是吧

46
00:02:50,575 --> 00:02:51,809
你们都体会到了

47
00:02:54,000 --> 00:02:57,725
如果你现在去你最喜欢的应用的下载页面

48
00:02:57,725 --> 00:03:00,560
可能你会找到它的

49
00:03:01,175 --> 00:03:04,125
Mac或Windows版的下载链接

50
00:03:04,850 --> 00:03:07,475
但对于Linux 你只能看到一堆乱七八糟的

51
00:03:07,475 --> 00:03:11,375
命令和代码仓库的链接

52
00:03:11,375 --> 00:03:16,725
没有给Linux简单方便地下载运行的方法

53
00:03:17,050 --> 00:03:18,707
如果你不相信我

54
00:03:18,707 --> 00:03:26,550
那现在就尝试从官网来下载VLC这个软件

55
00:03:26,550 --> 00:03:28,862
这样你就会知道我在说什么

56
00:03:31,850 --> 00:03:35,325
但是 如果换成使用AppImage格式将完全不同

57
00:03:35,325 --> 00:03:37,875
你只需要下载一个文件

58
00:03:38,119 --> 00:03:41,625
给予其可执行权限 通过一点点命令

59
00:03:41,625 --> 00:03:42,700
或者像我这样通过GUI界面操作

60
00:03:43,375 --> 00:03:45,530
就能直接运行它了

61
00:03:45,530 --> 00:03:50,825
我们不需要软件仓库 也不需要折腾

62
00:03:51,175 --> 00:03:57,100
只需要从应用程序原作者那里下载一个文件就能运行它了

63
00:03:59,825 --> 00:04:02,600
假设我是一名应用程序开发者

64
00:04:03,150 --> 00:04:07,103
我想为Linux桌面系统提供软件包

65
00:04:07,103 --> 00:04:12,275
但不必为每一个Linux发行版

66
00:04:12,275 --> 00:04:14,525
都进行编译

67
00:04:16,543 --> 00:04:19,167
你可能认为这有点扯

68
00:04:19,167 --> 00:04:22,850
但是，一旦你试图把你的应用程序

69
00:04:22,850 --> 00:04:22,860
发布到每一个发行版中去

70
00:04:22,860 --> 00:04:25,075
发布到每一个发行版中去

71
00:04:25,075 --> 00:04:28,425
这里我只是列出常见的几个系统

72
00:04:28,925 --> 00:04:31,227
这时你就会明白我在说什么了

73
00:04:31,650 --> 00:04:37,750
当然如果你也能等应用打包者们打包你的应用

74
00:04:37,750 --> 00:04:39,650
不过等到那时

75
00:04:39,650 --> 00:04:42,725
可能你的程序已经更新了5个版本了

76
00:04:43,000 --> 00:04:48,102
这真的不是一个便捷快速的方法

77
00:04:50,025 --> 00:04:55,975
这段话应该很多人都知道对吧

78
00:04:55,975 --> 00:05:00,000
Linus Trovalds在DebConf 2014

79
00:05:00,000 --> 00:05:02,735
会议上的一段话

80
00:05:03,650 --> 00:05:05,400
他这么说的

81
00:05:06,300 --> 00:05:09,625
我们基本上不会为Linux应用程序制作二进制文件

82
00:05:10,258 --> 00:05:16,679
因为给Liunx桌面程序制作二进制文件 比被爆菊还难受

83
00:05:16,679 --> 00:05:19,225
你可能刚刚为 Fedora 19 制作完二进制文件

84
00:05:19,900 --> 00:05:22,750
接着又要为 Fedora 20 重新制作二进制文件

85
00:05:22,750 --> 00:05:26,175
甚至可能需要为 RHEL 5 这样十年前的

86
00:05:26,175 --> 00:05:28,050
系统制作二进制文件

87
00:05:28,050 --> 00:05:32,035
还有 Debian stable 等等等等（想想就头大）

88
00:05:32,035 --> 00:05:36,575
也许我应该在这里插入Linus说这句话的视频

89
00:05:40,250 --> 00:05:42,225
另一个例子 作为测试者

90
00:05:42,225 --> 00:05:51,610
我想同时运行 Jenkins 或 Travis CI 进行快速且有条不紊的连续构建项目

91
00:05:54,800 --> 00:05:58,225
看下我们的解决方案

92
00:05:59,825 --> 00:06:03,350
首先，我们的目标是什么

93
00:06:04,650 --> 00:06:07,275
它应该是简单的

94
00:06:08,125 --> 00:06:11,369
其次 它还应该保持二进制兼容性

95
00:06:11,369 --> 00:06:14,735
如果不能变成可以在你的系统上运行的二进制文件

96
00:06:14,735 --> 00:06:18,875
那么即便是最伟大的源代码也无济于事

97
00:06:19,575 --> 00:06:22,600
最后 它也应该拥有很好的兼容性

98
00:06:24,315 --> 00:06:24,468
我们的解决方案是

99
00:06:24,468 --> 00:06:25,860
我们的解决方案是

100
00:06:25,860 --> 00:06:32,025
它不需要在任何发行版做特别的依赖支持

101
00:06:32,025 --> 00:06:35,850
所以应该保证这个解决方案能在

102
00:06:35,850 --> 00:06:38,875
当今绝大多数的 Linux 发行版上运行

103
00:06:40,425 --> 00:06:45,199
我们也想完全跳过安装这一必须步骤

104
00:06:45,525 --> 00:06:50,450
例如 如果你使用像 LibreOffice 这样的大型应用程序

105
00:06:50,850 --> 00:06:53,800
但你不想非得先安装它

106
00:06:53,800 --> 00:06:57,211
感觉这很像 Windows 95 对吧

107
00:06:57,211 --> 00:07:02,525
你要下载然后安装，并傻傻的看着进度条

108
00:07:02,825 --> 00:07:05,462
从左边移动到右边

109
00:07:05,462 --> 00:07:08,875
我希望完全消除安装的过程

110
00:07:08,875 --> 00:07:11,300
换一种说法

111
00:07:11,575 --> 00:07:19,775
应用程序在下载完的时候和在运行他的时侯应该是一模一样的

112
00:07:20,250 --> 00:07:23,883
这也意味着我们可以一直保持应用程序压缩着

113
00:07:23,883 --> 00:07:27,211
我们不必解包或解压缩应用程序

114
00:07:27,725 --> 00:07:31,102
这个工作在运行程序时就已经悄悄做好了

115
00:07:32,350 --> 00:07:37,025
我们的设计也允许我们把应用程序放在任何地方

116
00:07:37,629 --> 00:07:40,253
换一种说法就是，它是绿色软件

117
00:07:40,625 --> 00:07:44,125
这可以允许你把应用程序放在USB存储设备中

118
00:07:44,125 --> 00:07:46,000
并让你很方便的带走它

119
00:07:47,050 --> 00:07:50,327
应用程序是只读的

120
00:07:50,327 --> 00:07:51,150
这意味着你必须确保

121
00:07:51,150 --> 00:07:58,986
你已经下载的应用程序 100% 不会以任何方式改变自身

122
00:08:00,450 --> 00:08:06,111
在制作这些软件包的时候也应该考虑到这些

123
00:08:06,111 --> 00:08:09,311
即使我们没有应用程序全部的源代码

124
00:08:09,311 --> 00:08:15,775
应该也可以用这种方式来封装应用程序

125
00:08:16,900 --> 00:08:21,424
我们还希望保持基础操作系统的纯洁

126
00:08:21,775 --> 00:08:23,125
这不仅意味着

127
00:08:23,125 --> 00:08:25,383
你只是下载并运行一个软件

128
00:08:25,383 --> 00:08:29,863
而且它不会改变你的系统依赖库

129
00:08:30,250 --> 00:08:31,250
这同时也意味着

130
00:08:31,750 --> 00:08:36,600
运行以这种方式打包的应用程序时

131
00:08:36,971 --> 00:08:43,625
不会有任何运行时或二进制文件需要被安装

132
00:08:43,625 --> 00:08:46,617
在我们开始使用这个系统之前

133
00:08:47,513 --> 00:08:50,975
最后，这一切都不应该需要 root 权限。

134
00:08:51,850 --> 00:08:55,382
所以创建这样一个体系是可能的吗

135
00:08:56,400 --> 00:08:59,200
当然 接下来是一些核心理念

136
00:09:00,425 --> 00:09:03,425
我们的核心理念是

137
00:09:03,700 --> 00:09:08,100
一个软件等于一个文件

138
00:09:08,350 --> 00:09:12,600
这让我们管理软件变得很容易

139
00:09:12,600 --> 00:09:16,900
不需要任何包管理器和复杂的系统

140
00:09:17,500 --> 00:09:21,225
如果你要记住这段视频的一句话的话

141
00:09:21,225 --> 00:09:27,125
那就是Appimage致力于让一个软件等于一个文件

142
00:09:28,000 --> 00:09:33,525
当然 这个单文件不需要包含这个软件

143
00:09:33,525 --> 00:09:36,450
运行所需的所有东西

144
00:09:36,450 --> 00:09:45,296
只要包含那些我们无法有理有据地假设其存在的东西

145
00:09:45,575 --> 00:09:46,575
这就意味着

146
00:09:46,575 --> 00:09:52,391
除了那些一般发行版都预装的以外

147
00:09:52,391 --> 00:09:57,175
其实AppImage是包含所有需要的组件的

148
00:09:59,700 --> 00:10:02,119
另一个关于AppImage的核心理念是

149
00:10:02,119 --> 00:10:06,300
我们不允许包含任何

150
00:10:06,300 --> 00:10:12,120
我们认为已经包含在系统里的组件

151
00:10:12,120 --> 00:10:16,174
只要我们认为某些合适的依赖库

152
00:10:16,174 --> 00:10:19,450
已包含在主流发行版中

153
00:10:19,450 --> 00:10:24,250
我们就不必包含在AppImage内

154
00:10:24,550 --> 00:10:26,650
但是觉得异议的话

155
00:10:26,650 --> 00:10:26,670
那我们就会包含进去

156
00:10:26,670 --> 00:10:28,525
那我们就会包含进去

157
00:10:30,870 --> 00:10:33,000
还有一个打包AppImage的核心思想是

158
00:10:33,000 --> 00:10:39,000
打包并分发给你的用户应该是直接地

159
00:10:39,000 --> 00:10:44,325
而不被任何中间机构比如Repo那样的东西挡在你

160
00:10:44,325 --> 00:10:48,794
也就是作者跟用户之间

161
00:10:49,275 --> 00:10:54,525
别的系统中也利用了这个成功的模式

162
00:10:54,800 --> 00:11:01,300
有的系统还有应用商店认为你能自己判断

163
00:11:01,300 --> 00:11:09,950
但我还是认为应用的作者和用户之间不应有任何媒介

164
00:11:10,300 --> 00:11:12,900
最终一个核心思想 极简致胜

165
00:11:13,425 --> 00:11:16,325
为此 我们去掉了所有复杂的东西

166
00:11:16,325 --> 00:11:18,305
并且达到最大化的精简

167
00:11:21,075 --> 00:11:23,295
那什么是AppImage呢

168
00:11:24,350 --> 00:11:27,800
AppImagea是我谈到过的单文件应用程序

169
00:11:27,800 --> 00:11:35,625
实际上你可以把应用的每一个版本都弄成一个的单文件

170
00:11:35,625 --> 00:11:37,775
它们能够共存

171
00:11:38,225 --> 00:11:40,800
应用的镜像包含两部分

172
00:11:41,250 --> 00:11:45,062
第一部分是一些少量的可执行头部

173
00:11:45,650 --> 00:11:50,475
第二部分包含应用的主体的磁盘镜像

174
00:11:51,475 --> 00:11:56,370
现在 引导程序是一个常规的 ELF 二进制文件

175
00:11:56,370 --> 00:11:58,875
一个 Linux 可执行的二进制文件

176
00:11:58,875 --> 00:12:01,421
用来挂载磁盘镜像

177
00:12:01,650 --> 00:12:06,167
然后执行这个磁盘镜像的可执行文件

178
00:12:06,800 --> 00:12:09,875
这是通过 fuse 挂载的

179
00:12:09,875 --> 00:12:14,325
也就是说 你不需要用 root 权限挂载 AppImage

180
00:12:17,150 --> 00:12:21,275
这个磁盘镜像本身是一个常规的 ISO 文件

181
00:12:21,650 --> 00:12:23,125
它同时也被压缩了 

182
00:12:23,125 --> 00:12:29,391
每个 Linux 发行版都有的标准内核的方法挂载

183
00:12:29,391 --> 00:12:32,675
如果你想深入查看磁盘镜像

184
00:12:32,675 --> 00:12:36,250
只需要用loop参数挂载 就能查看它包含的内容

185
00:12:36,675 --> 00:12:39,426
磁盘镜像包含了你的应用的 payload

186
00:12:39,426 --> 00:12:45,350
也就是应用程序和依赖

187
00:12:47,426 --> 00:12:51,138
AppDir是什么呢

188
00:12:51,138 --> 00:12:52,700
应用目录（Applycation Directory）

189
00:12:54,425 --> 00:12:59,700
应用目录是一个文件系统树

190
00:12:59,975 --> 00:13:06,695
我们所假设基本系统不包含的依赖

191
00:13:07,720 --> 00:13:10,850
另外有一个文件叫AppRun

192
00:13:10,850 --> 00:13:13,100
这是程序的主入口点

193
00:13:13,750 --> 00:13:19,700
这就是当你运行 AppImage 时运行的程序

194
00:13:22,275 --> 00:13:26,700
创建 AppDir 时你应该时刻记住

195
00:13:26,700 --> 00:13:38,075
 AppDir 必须不依赖那些不是你所有的目标平台中都有的东西

196
00:13:39,350 --> 00:13:42,125
最实际的做法是

197
00:13:42,425 --> 00:13:45,950
在一个比最老的目标平台还要老旧

198
00:13:45,950 --> 00:13:48,775
的平台来编译你的应用

199
00:13:50,175 --> 00:13:55,075
然后将所有目标系统中缺少的文件

200
00:13:55,075 --> 00:13:58,525
打包到 AppImage 文件中

201
00:14:00,450 --> 00:14:02,550
还有一些 ideas

202
00:14:03,525 --> 00:14:05,262
比如软件的更新方式

203
00:14:06,525 --> 00:14:12,925
如果我们我们有一个约 100 兆的 AppImage

204
00:14:13,175 --> 00:14:17,775
假设我们为这个软件做每日构建版本

205
00:14:17,775 --> 00:14:21,975
如果每天都需要去下载那个 100 多兆大的文件

206
00:14:21,975 --> 00:14:22,925
那可不太妙

207
00:14:23,850 --> 00:14:25,675
所以利用增量升级的方法

208
00:14:25,675 --> 00:14:30,598
我们只需下载应用中发生变化的部分

209
00:14:30,598 --> 00:14:33,198
在实际应用中 需要重新下载的部分不会很多

210
00:14:33,198 --> 00:14:35,924
我对一大批应用进行过这方面的测试

211
00:14:36,975 --> 00:14:39,263
对很多应用而言只需要下载差不多约 2 兆大小的文件

212
00:14:39,263 --> 00:14:42,370
就可以完成从一个每日构建版本到另一个的升级

213
00:14:42,370 --> 00:14:44,250
这种方法在实际应用中切实有效

214
00:14:44,575 --> 00:14:48,276
我在这里给出一个链接供您亲自尝试

215
00:14:48,925 --> 00:14:52,025
下一个想法是使用沙箱技术

216
00:14:52,800 --> 00:14:56,350
沙箱技术不仅让应用更易于运行

217
00:14:56,350 --> 00:14:58,750
还让运行应用在某种程度上变得更加安全

218
00:14:58,750 --> 00:15:03,375
比方说将应用限制在一个只读文件系统中

219
00:15:03,375 --> 00:15:05,459
它便不能进行一些恶意行为

220
00:15:05,459 --> 00:15:09,050
例如删除你的home目录下的文件,或者其他类似行为

221
00:15:09,725 --> 00:15:14,325
我已经针对这个想法进行了一些实验

222
00:15:14,950 --> 00:15:18,525
最后 我们也希望与构建系统有机结合

223
00:15:19,948 --> 00:15:29,625
使得制作 AppImage 最终和编译普通软件一样简单

224
00:15:29,901 --> 00:15:33,676
为了实现这个目标 我们计划将 AppImageKit 与构建系统结合起来

225
00:15:34,025 --> 00:15:38,250
不过现在我必须说 我并不是一个精通编译系统的人

226
00:15:38,250 --> 00:15:42,925
所以如果有人在这个领域有开发经验 请来联系我

227
00:15:42,925 --> 00:15:48,950
我们可以一起完成将 AppImageKit 与构建系统结合的任务

228
00:15:50,675 --> 00:15:53,925
以上是我的想法

229
00:15:53,925 --> 00:15:56,325
正如我前面所说的

230
00:15:56,800 --> 00:15:58,562
十年多的时间 我一直在做这个项目

231
00:15:59,150 --> 00:16:00,375
那些反对意见又是怎样的呢

232
00:16:00,375 --> 00:16:03,703
事实上 有各种各样的反对的声音混杂在一起

233
00:16:03,703 --> 00:16:06,500
这里是一些典型的意见

234
00:16:07,900 --> 00:16:11,025
"这个工具的存在是多此一举"

235
00:16:12,050 --> 00:16:18,350
一些没看到 AppImage 作为系统包管理器补充的必要性的用户

236
00:16:18,350 --> 00:16:20,260
经常发出这样的反对声音

237
00:16:20,260 --> 00:16:23,442
我们来看看另一个

238
00:16:23,442 --> 00:16:30,610
我们来看看另一个

239
00:16:30,610 --> 00:16:35,319
"如果某个玩意儿是开源的 我们就不需要这个东西

240
00:16:35,319 --> 00:16:38,900
打包者打包完了或者必要时传输需要的库就行了"

241
00:16:38,900 --> 00:16:42,459
好吧 也许是这样 你可以试试

242
00:16:42,459 --> 00:16:45,900
下载喜欢的软件的最新版本 

243
00:16:45,900 --> 00:16:50,723
我们来试试前几天才发布的 Krita 3.0

244
00:16:51,225 --> 00:16:57,300
你会发现如果你用的不是 CentOS 6.0 的话使用它很困难

245
00:17:00,000 --> 00:17:01,464
另一个是

246
00:17:02,100 --> 00:17:07,100
"这样解包的话将会是安全噩梦"

247
00:17:08,000 --> 00:17:10,600
有两个方面 

248
00:17:10,600 --> 00:17:11,849
第一个是

249
00:17:11,850 --> 00:17:17,399
当我从原作者那里下载些东西时

250
00:17:17,400 --> 00:17:21,400
也就时我相信这个软件和他的作者

251
00:17:21,400 --> 00:17:24,325
否则我压根不会去运行

252
00:17:25,500 --> 00:17:32,000
对我来说 我更喜欢运行从源头获取的软件

253
00:17:32,000 --> 00:17:35,100
相比之下 从那些中间人哪里获取的

254
00:17:35,100 --> 00:17:38,800
你永远不知道他们对原文件做了什么

255
00:17:38,800 --> 00:17:44,525
不论那些是否经过原作者同意的更改

256
00:17:45,975 --> 00:17:47,350
第二个是

257
00:17:47,350 --> 00:17:51,050
我们没有“沙箱” 但是像我提到的

258
00:17:51,050 --> 00:17:56,970
我正在实验提供一个可选的沙箱来运行程序

259
00:17:56,970 --> 00:17:59,605
比如说在一个只读的限制环境之类的

260
00:18:02,900 --> 00:18:08,900
然后收到这些反馈后的很长一段时间

261
00:18:08,900 --> 00:18:14,800
我几乎要放弃给 Linux 的想法这个想法了

262
00:18:16,150 --> 00:18:18,675
我还觉得这跟文化很有关系

263
00:18:18,675 --> 00:18:23,160
这种东西在 OS 10 一直很不错

264
00:18:23,160 --> 00:18:28,525
而且 Apple 世界里经过多年的考验

265
00:18:28,525 --> 00:18:28,530
看起来 linux 用户有些不同

266
00:18:28,530 --> 00:18:31,200
看起来 linux 用户有些不同

267
00:18:31,200 --> 00:18:34,000
他们居然不赞同这个点子

268
00:18:36,175 --> 00:18:37,741
直到那时

269
00:18:38,525 --> 00:18:41,366
这是 Linus Torvalds 说的

270
00:18:41,366 --> 00:18:44,459
他试用了 AppImage

271
00:18:44,459 --> 00:18:48,300
得出的结论是 ”这玩意儿超酷"

272
00:18:48,300 --> 00:18:52,975
进入屏幕下方的链接

273
00:18:52,975 --> 00:19:00,000
那里有很多的讨论 还有所有信息的来源及更多信息

274
00:19:00,000 --> 00:19:06,250
linus是真的证实了 AppImage 和 AppImagekit 的理念

275
00:19:06,250 --> 00:19:07,500
 这真的很棒

276
00:19:09,475 --> 00:19:10,675
其他人也赞同这一点

277
00:19:10,675 --> 00:19:14,125
比如一个现任的 subsurface 项目的维护者

278
00:19:14,125 --> 00:19:17,606
他说 "AppImage 确实非常非常有用"

279
00:19:19,590 --> 00:19:25,149
从那开始很多开源软件开始采用 AppImage

280
00:19:25,400 --> 00:19:26,525
例如 krita（免费开源的绘图软件）

281
00:19:26,525 --> 00:19:28,700
现在在他们的下载页面提供AppImage 版本

282
00:19:29,123 --> 00:19:33,700
就像他们给 Windows 和 Mac 上提供的一致

283
00:19:35,225 --> 00:19:40,775
还有 scribus 项目 一个开源电子杂志制作软件

284
00:19:40,775 --> 00:19:44,725
同样在下载页面为 Linux 提供了 AppImage

285
00:19:44,725 --> 00:19:46,400
甚至为候选版本提供了 AppImage 下载

286
00:19:47,900 --> 00:19:54,600
Musescore 音乐软件现在不仅为 64 位系统提供 AppImage

287
00:19:54,600 --> 00:19:58,050
而且也为 32 位系统提供AppImage

288
00:19:58,050 --> 00:19:59,969
甚至为ARM系统提供

289
00:19:59,969 --> 00:20:01,413
所以你甚至可以在你的手机

290
00:20:01,413 --> 00:20:03,600
平板电脑或者树莓派上运行它

291
00:20:06,825 --> 00:20:10,114
那么怎样才能制作一个 AppImage 呢

292
00:20:12,550 --> 00:20:15,359
它真的不是那么复杂

293
00:20:16,025 --> 00:20:18,171
在这里我展示了一个小小的 helloworld 示例

294
00:20:18,171 --> 00:20:21,549
重新包装现有的二进制文件

295
00:20:21,549 --> 00:20:27,825
在这里我把下好的 leafpad（linux下一款轻量级编辑器）的 deb 软件包

296
00:20:28,250 --> 00:20:32,014
转换成为了一个 AppImage 包

297
00:20:32,275 --> 00:20:39,350
我做的第一件事是为 leafpad 建立一个 AppDir 目录

298
00:20:40,525 --> 00:20:47,049
然后下载 deb 软件包 接下来进入 AppDir 目录

299
00:20:48,450 --> 00:20:54,950
解压 deb 包 复制图标文件和桌面链接文件

300
00:20:54,950 --> 00:21:03,675
到 AppDir 的根目录之后从 AppImagekit 获取 AppRun 文件

301
00:21:03,675 --> 00:21:04,600
重复一下

302
00:21:04,600 --> 00:21:08,919
AppRun 文件是进入 AppDir 的主入口点

303
00:21:08,919 --> 00:21:15,149
我以前谈过这个 它的作用是启动应用程序

304
00:21:15,800 --> 00:21:24,399
最后我退出 AppDir 目录 然后我使用 AppImagetool

305
00:21:24,399 --> 00:21:27,639
将 AppDir 转换成 AppImage 这真的很简单

306
00:21:27,639 --> 00:21:29,725
结果便是一个可以运行的 AppImage

307
00:21:30,450 --> 00:21:32,225
在这个例子中

308
00:21:32,225 --> 00:21:40,545
至少是一个可以运行在打包系统或更新的系统的 AppImage

309
00:21:40,545 --> 00:21:49,100
所以在一个你能得到的最旧的发行版上编译二进制文件比较好

310
00:21:51,750 --> 00:21:57,225
在现实世界中 你想做的可能不只是

311
00:21:57,659 --> 00:21:59,850
重新打包已有的二进制软件

312
00:21:59,850 --> 00:22:03,659
但是在自己构建的时候

313
00:22:03,659 --> 00:22:05,359
最好使用一个成熟的发行版

314
00:22:06,250 --> 00:22:10,175
最好是你能够找到的最老的发行版本

315
00:22:10,175 --> 00:22:14,550
以便你能够找到一个现成的编译器和构建工具

316
00:22:15,300 --> 00:22:19,225
这些我已经成功在 Centos 6 上实现了

317
00:22:19,950 --> 00:22:24,925
此外要保证你打包的应用没有硬编码路径

318
00:22:25,600 --> 00:22:32,075
否则你要在源码甚至二进制文件上打上补丁

319
00:22:33,400 --> 00:22:37,150
剩下要做的就和前面我所说的一样了

320
00:22:37,700 --> 00:22:40,275
把你的应用转换成 AppDir

321
00:22:40,700 --> 00:22:49,400
并且你应该把各个需要调用的库也打包进 AppDir 里面

322
00:22:49,400 --> 00:22:55,108
也就是说如果你的应用调用了一个非常新的库

323
00:22:55,525 --> 00:23:01,575
你必须把这个库包含到AppImage中

324
00:23:02,340 --> 00:23:06,925
最后当你成功构建出你的应用镜像 请在各个发行版进行测试

325
00:23:06,925 --> 00:23:11,460
不要忽略这重要的一步

326
00:23:11,460 --> 00:23:19,400
我用各种 live 版的 Linux 操作系统

327
00:23:19,400 --> 00:23:22,550
测试我打包的 AppImage

328
00:23:26,000 --> 00:23:32,100
当你可以连续构建的时候 你会发现这是非常有趣的

329
00:23:32,825 --> 00:23:41,325
连续构建指的是每当有人提交了变更 你都可以自动化的构建你的软件

330
00:23:42,123 --> 00:23:51,907
如果你可以做到那样 那么你就可以在很短的时间内完成你的打包工作

331
00:23:51,907 --> 00:23:55,969
这将大大增加打包的效率

332
00:23:56,275 --> 00:24:00,225
想象一下这就像 Git 一样

333
00:24:03,125 --> 00:24:06,640
下面这就是我成功应用的一系列流程

334
00:24:06,640 --> 00:24:09,452
每当我把更新推送到 github

335
00:24:09,800 --> 00:24:13,904
然后 Travis CI 这个在云端的持续构建系统就会

336
00:24:13,904 --> 00:24:16,100
获取一个包含打包系统的 docker 容器

337
00:24:16,100 --> 00:24:19,000
在这里是 CentOS 6

338
00:24:19,000 --> 00:24:24,310
这个系统里面包含了所有预装的依赖

339
00:24:24,310 --> 00:24:28,569
然后在云端把应用打包成 AppImage

340
00:24:28,850 --> 00:24:34,875
再把它上传到 BinTray

341
00:24:34,875 --> 00:24:36,610
BinTray 是一个终端用户可以下载的网站

342
00:24:36,610 --> 00:24:44,856
我们可以把这个网址链接到 AppImage 上

343
00:24:45,675 --> 00:24:51,775
每当有人在 github 上推送提交后

344
00:24:51,775 --> 00:24:56,770
都能得到一个新的可运行的二进制文件

345
00:24:59,275 --> 00:25:05,875
你可以在 https://github.com/probonopd/ 上查看这个过程

346
00:25:05,875 --> 00:25:05,890
然后你就能看到我之前描述的

347
00:25:05,890 --> 00:25:10,075
然后你就能看到我之前描述的

348
00:25:11,581 --> 00:25:15,050
有一些软件已经打包好了 

349
00:25:15,050 --> 00:25:18,282
比如 MuseScore 和 Scribus

350
00:25:18,318 --> 00:25:20,975
请随意将这套流程

351
00:25:20,975 --> 00:25:23,975
应用于其他构建系统或者其他基础服务

352
00:25:23,975 --> 00:25:27,300
我希望更多人能接受并使用它

353
00:25:28,775 --> 00:25:31,990
如果你对此感兴趣我们非常欢迎 那么如何为 AppImage 做贡献呢

354
00:25:31,990 --> 00:25:34,800
首要途径就是大力宣传 AppImage

355
00:25:34,800 --> 00:25:36,900
让人们意识到

356
00:25:37,600 --> 00:25:42,275
这是一套行之有效的解决方案

357
00:25:43,450 --> 00:25:46,650
更好的办法是建议你喜欢的程序的

358
00:25:46,650 --> 00:25:51,550
上游社区讨论使用 AppImage 进行打包

359
00:25:52,225 --> 00:25:57,875
理想情况下社区可能会信心十足地直接采用 AppImage 打包

360
00:25:57,875 --> 00:25:57,880
甚至以后都这样打包发布

361
00:25:57,880 --> 00:26:02,435
甚至以后都这样打包发布

362
00:26:02,435 --> 00:26:09,260
话说回来 现在一些项目都是测试完就把构建的版本扔掉

363
00:26:09,260 --> 00:26:10,125
那真是太遗憾了

364
00:26:10,675 --> 00:26:13,375
本可以很容易地做出一个更适应未来的精品应用

365
00:26:14,925 --> 00:26:17,575
如果你想做的更多

366
00:26:17,575 --> 00:26:21,100
请向你最爱的上游软件社区建议

367
00:26:21,100 --> 00:26:23,375
打包一个 AppImage 格式应用

368
00:26:23,375 --> 00:26:28,275
但请注意 测试仍是必要的

369
00:26:28,725 --> 00:26:31,125
请在各种主流发行版上进行调试

370
00:26:31,125 --> 00:26:35,625
直至令人满意

371
00:26:37,400 --> 00:26:42,825
你也可以把 AppImage 的包整合进主要的基础软件设施中

372
00:26:42,825 --> 00:26:47,925
对于你自己的资源控制管理来说

373
00:26:48,400 --> 00:26:52,275
我之前给出的例子就是采用 github 或者

374
00:26:52,275 --> 00:26:59,500
Travis CI或者docker或者以二进制包的形式来适配你的打包流程

375
00:27:00,375 --> 00:27:04,450
最终你会为AppImage项目本身做出贡献

376
00:27:04,450 --> 00:27:06,958
比如一个可以自动生成AppImage的工具集

377
00:27:07,650 --> 00:27:08,800
现在有一个很好的例子

378
00:27:08,800 --> 00:27:10,700
就是AppImage更新工具

379
00:27:10,700 --> 00:27:15,175
还处在概念验证状态而且有点简陋和粗糙

380
00:27:15,175 --> 00:27:18,000
在这方面我们急需更多的帮助

381
00:27:19,275 --> 00:27:20,825
当遇到疑问时

382
00:27:21,350 --> 00:27:29,750
请立即在github提交issue

383
00:27:30,770 --> 00:27:38,466
 非常感谢您的观看！
翻译团队名单 策划/组织-小鸡 翻译-AliveGh0st/冷清°
时间轴-魍酃

