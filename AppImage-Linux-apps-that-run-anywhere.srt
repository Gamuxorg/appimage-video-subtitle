1
00:00:00,380 --> 00:00:01,640
AppImage中文社区制作 感谢收看！

00:00:01,640 --> 00:00:05,640
本篇介绍AppImage
它由Simon Peter开发 能使Linux应用随处运行

2
00:00:05,640 --> 00:00:12,059
AppImage是一种用于分发上游提供
的应用二进制文件的格式

3
00:00:12,059 --> 00:00:17,580
这让用户可以轻松地获取和运行
最新版本的Linux应用程序

4
00:00:17,580 --> 00:00:23,250
甚至那些只包含stable软件的系统都能运行
（例如Debian Stable和CentOS）

5
00:00:23,250 --> 00:00:28,380
这意味着软件包不会以任何形式
干扰基础系统所安装的依赖库

6
00:00:28,380 --> 00:00:33,510
换句话说 当你下载一个AppImage文件后


7
00:00:33,510 --> 00:00:39,360
它不会影响你的基础系统 也使得上游
软件开发方为Linux提供

8
00:00:39,360 --> 00:00:44,640
正式版和每日构建版或连续构建版变得很容易


9
00:00:44,640 --> 00:00:50,969
就像以前他们倾向于为mac OS和Windows提供这些
但很多时候不为Linux提供

10
00:00:50,969 --> 00:00:55,980
现在有了AppImage 实现起来就很容易了
并且我认为通过我所说的软件开发流水线化可加快测试速度

11
00:00:59,160 --> 00:01:06,810
这让发布、下载、测试和制作都变得非常方便
也让制作周期变得更短

12
00:01:06,810 --> 00:01:12,290
并且AppImage不需要任何中间机构

13
00:01:12,290 --> 00:01:17,310
如果用软件源这类

14
00:01:17,310 --> 00:01:23,610
你还得考虑的是如何把你的开源软件弄进软件源

15
00:01:23,610 --> 00:01:29,970
现在你可以为你的最终用户直接提供你的应用

16
00:01:29,970 --> 00:01:38,579
你和你最终用户之间的没有任何第三方

17
00:01:38,579 --> 00:01:42,720
简单自我介绍一下 我是Simon
我是一名OS X和Linux live系统用户

18
00:01:42,720 --> 00:01:49,649
我不是一个真正的应用程序开发人员
但我已经跨界写代码超过十年了

19
00:01:49,649 --> 00:01:54,270
我从一个小的UI项目开始
它涉及到便携式Linux应用程序

20
00:01:54,270 --> 00:02:01,729
后来终于开始做AppImage
以前来自社区的反馈不太好

21
00:02:01,729 --> 00:02:06,750
所以我曾经几乎放弃这个想法

22
00:02:06,750 --> 00:02:10,140
但我终于超越了自己
视频后面我回过头来还要再谈这点

23
00:02:10,139 --> 00:02:16,250
现在让我们来阐述一个问题

24
00:02:16,250 --> 00:02:21,019 
那就是今天我们打包和分发
Linux应用的方式并不方便

25
00:02:21,019 --> 00:02:32,209
所以让我们开始吧
作为一个用户，我想从原始作者那里下载一个应用程序

26
00:02:32,209 --> 00:02:37,819
并且在软件发布已发布我就想让它在Linux上运行
就像Windows或Mac应用程序一样简单

00:02:40,640 --> 00:02:48,829
但目前对于Linux应用程序来说
想做到这一点并不容易 是吧

28
00:02:48,829 --> 00:02:51,230
你们都体会到了

29
00:02:55,310 --> 00:03:00,560
如果你现在去你最喜欢的应用的下载页面
可能你会找到它的

30
00:03:00,560 --> 00:03:08,709
Mac或Windows版的下载链接
但对于Linux 你只能看到一堆乱七八糟的

31
00:03:08,709 --> 00:03:13,730
命令和代码仓库的链接 
没有给Linux简单方便地下载

32
00:03:13,730 --> 00:03:19,220
运行的方法
如果你不相信我

33
00:03:19,220 --> 00:03:24,889
那现在就尝试从官网来下载VLC这个软件

34
00:03:24,889 --> 00:03:32,599
这样你就会知道我在说什么
但是 如果换成使用AppImage格式将完全不同

35
00:03:34,700 --> 00:03:40,669
你只需要下载一个文件 
给予其可执行权限 通过一点点命令

36
00:03:40,669 --> 00:03:45,530
或者像我这样通过GUI界面操作
就能直接运行它了

37
00:03:45,530 --> 00:03:53,180
我们不需要软件仓库 也不需要折腾

38
00:03:53,180 --> 00:04:01,010
只需要从应用程序原作者那里下载一个文件就能运行它了
假设我是一名应用程序开发者

39
00:04:04,040 --> 00:04:09,739
我想为Linux桌面系统提供软件包
但不必为每一个Linux发行版

40
00:04:09,739 --> 00:04:13,700
都进行编译
你可能认为这有点扯

41
00:04:17,870 --> 00:04:22,860
但是，一旦你试图把你的应用程序

42
00:04:22,860 --> 00:04:27,449
发布到每一个发行版中去
这里我只是列出常见的几个系统

43
00:04:27,449 --> 00:04:32,610
这时你就会明白我在说什么了
当然如果你也能等应用打包者们打包你的应用

44
00:04:32,610 --> 00:04:38,699
不过等到那时

45
00:04:38,699 --> 00:04:44,189
可能你的程序已经更新了5个版本了

46
00:04:44,189 --> 00:04:53,699
这真的不是一个便捷快速的方法
这段话应该很多人都知道对吧

47
00:04:53,699 --> 00:04:58,949
Linus Trovalds在DebConf 2014
会议上的一段话

48
00:04:58,949 --> 00:05:07,259
他这么说的

49
00:05:07,259 --> 00:05:12,780
我们基本上不会为Linux应用程序制作二进制文件
因为给Liunx桌面程序制作二进制文件 比被爆菊还难受

50
00:05:15,779 --> 00:05:21,210
你可能刚刚为 Fedora 19 制作完二进制文件

51
00:05:21,210 --> 00:05:27,509
接着又要为 Fedora 20 重新制作二进制文件
甚至可能需要为 RHEL 5 这样十年前的

52
00:05:27,509 --> 00:05:32,370
系统制作二进制文件
还有 Debian stable 等等等等（想想就头大） 

53
00:05:32,370 --> 00:05:41,550
也许我应该在这里插入Linus说这句话的视频

54
00:05:41,550 --> 00:05:47,460
另一个例子 作为测试者
我想同时运行 Jenkins 或 Travis CI 进行快速且有条不紊的连续构建项目

55
00:05:50,610 --> 00:06:05,400
看下我们的解决方案
首先，它应该是简单的

56
00:06:08,789 --> 00:06:13,830
其次 它还应该保持二进制兼容性
如果不能变成可以在你的系统上运行的二进制文件

57
00:06:13,830 --> 00:06:20,870
那么即便是最伟大的源代码也无济于事
最后 它也应该拥有很好的兼容性

58
00:06:20,870 --> 00:06:25,860
而且更进一步
我们的解决方案是

59
00:06:25,860 --> 00:06:30,409
它不需要在任何发行版做特别的依赖支持

60
00:06:30,409 --> 00:06:35,850
所以应该保证这个解决方案能在

61
00:06:35,850 --> 00:06:42,540
当今绝大多数的 Linux 发行版上运行
我们也想完全跳过安装这一必须步骤

62
00:06:42,540 --> 00:06:49,340
例如 如果你使用像 LibreOffice 这样的大型应用程序

63
00:06:52,350 --> 00:06:57,720
但你不想非得先安装它
感觉这很像 Windows 95 对吧

64
00:06:57,720 --> 00:07:02,300
你要下载然后安装，并傻傻的看着进度条

65
00:07:02,300 --> 00:07:07,770
从左边移动到右边
我希望完全消除安装的过程 

66
00:07:09,660 --> 00:07:17,070
换一种说法
应用程序在下载完的时候和在运行他的时侯应该是一模一样的

67
00:07:19,260 --> 00:07:22,290
这也意味着我们可以一直保持应用程序压缩着

68
00:07:22,290 --> 00:07:27,960
我们不必解包或解压缩应用程序
这个工作在运行程序时就已经悄悄做好了

69
00:07:31,850 --> 00:07:38,580
我们的设计也允许我们把应用程序放在任何地方
换一种说法就是，它是绿色软件

70
00:07:41,280 --> 00:07:47,780
这可以允许你把应用程序放在USB存储设备中
并让你很方便的带走它

71
00:07:47,780 --> 00:07:52,560
应用程序是只读的
这意味着你必须确保

72
00:07:52,560 --> 00:07:58,140
你已经下载的应用程序 100% 不会以任何方式改变自身

73
00:07:58,140 --> 00:08:06,480
在制作这些软件包的时候也应该考虑到这些

74
00:08:06,480 --> 00:08:10,950
即使我们没有应用程序全部的源代码
应该也可以用这种方式来封装应用程序

75
00:08:13,170 --> 00:08:22,140
我们还希望保持基础操作系统的纯洁
这不仅意味着

76
00:08:23,910 --> 00:08:29,040
你只是下载并运行一个软件
而且它不会改变你的系统依赖库

77
00:08:29,040 --> 00:08:35,729
这同时也意味着 不应该有任何运行时
或二进制文件

78
00:08:35,729 --> 00:08:43,229
需要被安装 


79
00:08:43,229 --> 00:08:49,050
在我们开始使用这个系统之前
最后，这一切都不应该需要 root 权限。


80
00:08:52,110 --> 00:09:01,320
所以创建这样一个体系是可能的吗
当然 接下来是一些核心理念

81
00:09:01,320 --> 00:09:07,170
我们的核心理念是 一个软件等于一个文件


82
00:09:09,630 --> 00:09:14,670
这让我们管理软件变得很容易


83
00:09:14,670 --> 00:09:20,460
不需要任何包管理器和复杂的系统


84
00:09:20,460 --> 00:09:26,130
如果你要记住这段视频的一句话的话 那就是
一个软件等于一个文件


85
00:09:26,130 --> 00:09:34,380
当然 这个单文件不需要包含这个软件
运行所需的所有东西


86
00:09:34,380 --> 00:09:40,230
只要包含那些我们无法有理有据地假设其存在的东西


87
00:09:40,230 --> 00:09:46,890
这就意味着


88
00:09:46,890 --> 00:09:52,980
除了那些一般发行版都预装的以外

89
00:09:52,980 --> 00:10:01,470
其实AppImage是包含所有需要的组件的
另一个关于AppImage的核心理念是


90
00:10:01,470 --> 00:10:07,200 
我们不允许包含任何

91
00:10:07,200 --> 00:10:13,020
我们认为已经包含在系统里的组件
只要我们认为某些合适的依赖库

92
00:10:15,540 --> 00:10:20,550
已包含在主流发行版中 我们就不必包含在AppImage内

93
00:10:20,550 --> 00:10:26,670
但是觉得异议的话

94
00:10:26,670 --> 00:10:35,130
那我们就会包含进去
还有一个打包AppImage的核心思想是


95
00:10:35,130 --> 00:10:41,130
打包并分发给你的用户应该是直接地


96
00:10:41,130 --> 00:10:45,810
而不被任何中间机构比如Repo那样的东西挡在你

97
00:10:45,810 --> 00:10:50,279
也就是作者跟用户之间

98
00:10:50,279 --> 00:10:56,850
别的系统中也利用了这个成功的模式

99
00:10:56,850 --> 00:11:02,250
有的系统还有应用商店
你能自己判断 但我还是认为

100
00:11:02,250 --> 00:11:06,690
应用的作者和用户之间不应有任何媒介

101
00:11:06,690 --> 00:11:11,610
最终一个核心思想 极简致胜

102
00:11:11,610 --> 00:11:16,920
为此 我们去掉了所有复杂的东西

103
00:11:16,920 --> 00:11:26,910
并且达到最大化的精简 那什么是AppImage呢
AppImagea是我谈到过的单文件应用程序

104
00:11:26,910 --> 00:11:32,79
实际上你可以把应用的每一个版本都弄成一个的单文件

105
00:11:32,790 --> 00:11:39,060
它们能够共存
应用的镜像包含两部分

106
00:11:39,060 --> 00:11:46,080
第一部分是一些少量的可执行头部

107
00:11:46,080 --> 00:11:52,560
第二部分包含应用的主体的磁盘镜像
现在 引导程序是一个常规的 ELF 二进制文件

108
00:11:56,370 --> 00:12:04,350
一个 Linux 可执行的二进制文件
用来挂载磁盘镜像

109
00:12:04,350 --> 00:12:10,770
然后执行这个磁盘镜像的可执行文件
这是通过 fuse 挂载的

110
00:12:10,770 --> 00:12:18,120
也就是说 你不需要用 root 权限挂载 AppImage 

111
00:12:18,120 --> 00:12:24,660
这个磁盘镜像本身是一个常规的 ISO 文件
它同时也被压缩了 可以每个 Linux 发行版

112
00:12:24,660 --> 00:12:29,580
都有的标准内核的方法挂载
如果你想深入查看磁盘镜像

113
00:12:29,580 --> 00:12:34,709
只需要用loop参数挂载 就能查看它包含的内容

114
00:12:38,520 --> 00:12:44,640
磁盘镜像包含了你的应用的 payload
也就是应用程序和依赖

115
00:12:44,640 --> 00:12:53,890
AppDir是什么呢
应用目录（Applycation Directory）

116
00:12:53,890 --> 00:13:01,000
应用目录是一个文件系统树

117
00:13:01,000 --> 00:13:07,720
我们所假设基本系统不包含的依赖

118
00:13:07,720 --> 00:13:13,750
另外有一个文件叫AppRun
这是程序的主入口点

119
00:13:13,750 --> 00:13:23,079
这就是当你运行 AppImage 时运行的程序

120
00:13:23,079 --> 00:13:29,440
创建 AppDir 时你应该时刻记住 AppDir 必须

121
00:13:29,440 --> 00:13:35,230
不依赖那些不是你所有的目标平台中都有的东西


122
00:13:35,230 --> 00:13:42,880
最实际的做法是

123
00:13:42,880 --> 00:13:48,190
在一个比最老的目标平台还要老旧
的平台来编译你的应用

124
00:13:50,175 --> 00:13:58,525
然后将所有目标系统中缺少的文件
打包到 AppImage 文件中

125
00:14:00,450 --> 00:14:02,550
还有一些 ideas

126
00:14:03,525 --> 00:14:05,262
比如软件的更新方式 

127
00:14:06,525 --> 00:14:12,925
如果我们我们有一个约 100 兆的 AppImage
假设我们为这个软件做每日构建版本

128
00:14:13,300 --> 00:14:22,980
如果每天都需要去下载那个 100 多兆大的文件
那可不太妙

129
00:14:23,850 --> 00:14:30,598
所以利用增量升级的方法
我们只需下载应用中发生变化的部分

130
00:14:30,598 --> 00:14:33,198
在实际应用中 需要重新下载的部分不会很多

131
00:14:33,198 --> 00:14:35,924
我对一大批应用进行过这方面的测试 

132
00:14:36,975 --> 00:14:39,263
对很多应用而言
只需要下载差不多约 2 兆大小的文件

133
00:14:39,263 --> 00:14:42,370
就可以完成从一个每日构建版本到另一个的升级

134
00:14:42,370 --> 00:14:44,250
这种方法在实际应用中切实有效 

135
00:14:44,575 --> 00:14:48,276
我在这里给出一个链接供您亲自尝试

136
00:14:48,925 --> 00:14:52,025
下一个想法是使用沙箱技术

137
00:14:52,800 --> 00:14:58,750
沙箱技术不仅让应用更易于运行
还让运行应用在某种程度上变得更加安全

138
00:14:58,750 --> 00:15:03,375
比方说将应用限制在一个只读文件系统中

139
00:15:03,375 --> 00:15:05,459
它便不能进行一些恶意行为

141
00:15:05,459 --> 00:15:09,050
例如删除你的home目录下的文件,或者其他类似行为

142
00:15:09,725 --> 00:15:14,325
我已经针对这个想法进行了一些实验

143
00:15:14,950 --> 00:15:18,525
最后 我们也希望与构建系统有机结合

144
00:15:19,948 --> 00:15:29,625
使得制作 AppImage 最终和编译普通软件一样简单

145
00:15:29,901 --> 00:15:33,676
为了实现这个目标 我们计划将 AppImageKit 与构建系统结合起来

146
00:15:34,025 --> 00:15:38,250
不过现在我必须说 我并不是一个精通编译系统的人

147
00:15:38,250 --> 00:15:42,925
所以如果有人在这个领域有开发经验 请来联系我

149
00:15:42,925 --> 00:15:48,950
我们可以一起完成将 AppImageKit 与构建系统结合的任务

151
00:15:50,675 --> 00:15:53,925
以上是我的想法

152
00:15:53,925 --> 00:15:56,325
正如我前面所说的

154
00:15:56,800 --> 00:15:58,562
十年多的时间 我一直在做这个项目

155
00:15:59,150 --> 00:16:00,375
那些反对意见又是怎样的呢

156
00:16:00,375 --> 00:16:03,703
事实上 有各种各样的反对的声音混杂在一起 

157
00:16:03,703 --> 00:16:06,500
这里是一些典型的意见

158
00:16:07,900 --> 00:16:11,025
"这个工具的存在是多此一举" 

159
00:16:12,050 --> 00:16:18,350
一些没看到 AppImage 作为系统包管理器补充的必要性的用户

160
00:16:18,350 --> 00:16:23,442
经常发出这样的反对声音

160
00:16:20,260 --> 00:16:30,610
我们来看看另一个

161
00:16:30,610 --> 00:16:35,319
"如果某个玩意儿是开源的 我们就不需要这个东西
打包者打包完了或者必要时传输需要的库就行了"

162
00:16:35,319 --> 00:16:42,459
好吧 也许是这样 你可以试试

163
00:16:42,459 --> 00:16:47,319
下载喜欢的软件的最新版本 我们来试试 Krita 3.0

164
00:16:47,319 --> 00:16:53,380
前几天才发布的 你会发现 如果你用的不是 CentOS 6.0 的话

165
00:16:53,380 --> 00:16:58,529
会很难用得上

166
00:17:00,000 --> 00:17:06,040
另一个是
"这样解包的话将会是安全噩梦"

167
00:17:06,040 --> 00:17:11,850
有两个方面 第一个是

168
00:17:11,849 --> 00:17:17,399
当我从原作者那里下载些东西时

169
00:17:17,400 --> 00:17:22,650
也就时我相信这个软件和他的作者
否则我压根不会去运行

170
00:17:22,650 --> 00:17:32,910
对我来说 我更喜欢运行从源头获取的软件

172
00:17:32,910 --> 00:17:37,290
相比之下 从那些中间人哪里获取的
你永远不知道他们对原文件做了什么

173
00:17:39,450 --> 00:17:46,530
不论那些是否经过原作者同意的更改
第二个是

174
00:17:46,530 --> 00:17:51,050
我们没有“沙箱” 但是像我提到的

175
00:17:51,050 --> 00:17:56,970
我正在实验提供一个可选的沙箱来运行程序

176
00:17:56,970 --> 00:18:05,880
比如说在一个只读的限制环境之类的

177
00:18:05,880 --> 00:18:12,600
然后收到这些反馈后的很长一段时间
我几乎要放弃给 Linux 的想法这个想法了

178
00:18:17,250 --> 00:18:23,160
我还觉得这跟文化很有关系
这种东西在 OS 10 一直很不错

179
00:18:23,160 --> 00:18:28,530
而且 Apple 世界里经过多年的考验

180
00:18:28,530 --> 00:18:32,400
看起来 linux 用户有些不同
他们居然不赞同这个点子

181
00:18:32,400 --> 00:18:41,220
直到那时
这是 Linus Torvalds 说的

182
00:18:41,220 --> 00:18:47,190
他试用了 AppImage
得出的结论是 ”这玩意儿超酷"

183
00:18:47,190 --> 00:18:52,260
进入屏幕下方的链接

184
00:18:52,260 --> 00:18:57,900
那里有很多的讨论 还有所有信息的来源及更多信息

185
00:18:57,900 --> 00:19:07,500
linus是真的证实了 AppImage 和 AppImagekit 的理念 这真的很棒

186
00:19:09,475 --> 00:19:10,675
其他人也赞同这一点

187
00:19:10,675 --> 00:19:14,125
比如一个现任的 subsurface 项目的维护者

188
00:19:14,125 --> 00:19:17,606
他说 "AppImage 确实非常非常有用"

189
00:19:19,590 --> 00:19:25,149
从那开始很多开源软件开始采用 AppImage

190
00:19:25,400 --> 00:19:26,525
例如 krita（免费开源的绘图软件）

191
00:19:26,525 --> 00:19:28,700
现在在他们的下载页面提供AppImage 版本

192
00:19:29,123 --> 00:19:33,700
就像他们给 Windows 和 Mac 上提供的一致

193
00:19:35,225 --> 00:19:40,775
还有 scribus 项目 一个开源电子杂志制作软件

194
00:19:40,775 --> 00:19:46,600
同样在下载页面为 Linux 提供了 AppImage
甚至为候选版本提供了 AppImage 下载

195
00:19:47,900 --> 00:19:54,600
Musescore 音乐软件现在不仅为 64 位系统提供 AppImage

196
00:19:54,600 --> 00:19:59,969
而且也为 32 位系统提供AppImage
甚至为ARM系统提供

197
00:19:59,969 --> 00:20:03,675
所以你甚至可以在你的手机
平板电脑或者树莓派上运行它

198
00:20:06,825 --> 00:20:10,114
那么怎样才能制作一个 AppImage 呢

199
00:20:12,550 --> 00:20:15,359
它真的不是那么复杂

200
00:20:16,025 --> 00:20:21,549
在这里我展示了一个小小的 helloworld 示例
重新包装现有的二进制文件

201
00:20:21,549 --> 00:20:27,825
在这里我把下好的 leafpad（linux下一款轻量级编辑器）的 deb 软件包

202
00:20:28,250 --> 00:20:32,014
转换成为了一个 AppImage 包

203
00:20:32,275 --> 00:20:39,350
我做的第一件事是为 leafpad 建立一个 AppDir 目录

204
00:20:40,525 --> 00:20:47,049
然后下载 deb 软件包 接下来进入 AppDir 目录

205
00:20:48,450 --> 00:20:54,950
解压 deb 包 复制图标文件和桌面链接文件

206
00:20:54,950 --> 00:21:03,675
到 AppDir 的根目录之后从 AppImagekit 获取 AppRun 文件

207
00:21:04,025 --> 00:21:08,919
重复一下
AppRun 文件是进入 AppDir 的主入口点

208
00:21:08,919 --> 00:21:15,149
我以前谈过这个 它的作用是启动应用程序

209
00:21:15,800 --> 00:21:24,399
最后我退出 AppDir 目录 然后我使用 AppImagetool

210
00:21:24,399 --> 00:21:27,639
将 AppDir 转换成 AppImage 这真的很简单

211
00:21:27,639 --> 00:21:29,725
结果便是一个可以运行的 AppImage 

212
00:21:30,450 --> 00:21:40,54500:21:36,090
在这个例子中
至少是一个可以运行在打包系统或更新的系统的 AppImage

214
00:21:40,545 --> 00:21:49,100
所以在一个你能得到的最旧的发行版上编译二进制文件比较好

215
00:21:51,750 --> 00:21:57,225
在现实世界中 你想做的可能不只是

216
00:21:57,659 --> 00:21:59,850
重新打包已有的二进制软件

217
00:21:59,850 --> 00:22:03,659
但是在自己构建的时候

218
00:22:03,659 --> 00:22:05,359
最好使用一个成熟的发行版

219
00:22:06,250 --> 00:22:10,175
最好是你能够找到的最老的发行版本

220
00:22:10,175 --> 00:22:14,550
以便你能够找到一个现成的编译器和构建工具

221
00:22:15,300 --> 00:22:19,225
这些我已经成功在 Centos 6 上实现了

222
00:22:19,950 --> 00:22:24,925
此外要保证你打包的应用没有硬编码路径

223
00:22:25,600 --> 00:22:32,075
否则你要在源码甚至二进制文件上打上补丁

224
00:22:33,400 --> 00:22:37,150
剩下要做的就和前面我所说的一样了

225
00:22:37,700 --> 00:22:40,275
把你的应用转换成 AppDir

226
00:22:40,700 --> 00:22:49,400
并且你应该把各个需要调用的库也打包进 AppDir 里面

227
00:22:49,400 --> 00:22:55,108
也就是说如果你的应用调用了一个非常新的库

228
00:22:55,525 --> 00:23:01,575
你必须把这个库包含到AppImage中

229
00:23:02,340 --> 00:23:06,925
最后当你成功构建出你的应用镜像 请在各个发行版进行测试

230
00:23:06,925 --> 00:23:11,460
不要忽略这重要的一步

231
00:23:11,460 --> 00:23:19,400
我用各种 live 版的 Linux 操作系统

232
00:23:19,400 --> 00:23:22,550
测试我打包的 AppImage

233
00:23:26,000 --> 00:23:32,100
当你可以连续构建的时候 你会发现这是非常有趣的

234
00:23:32,825 --> 00:23:41,325
连续构建指的是每当有人提交了变更 你都可以自动化的构建你的软件

235
00:23:42,123 --> 00:23:51,907
如果你可以做到那样 那么你就可以在很短的时间内完成你的打包工作

236
00:23:51,907 --> 00:23:55,969
这将大大增加打包的效率

237
00:23:56,275 --> 00:24:00,225
想象一下这就像 Git 一样

238
00:24:03,125 --> 00:24:06,640
下面这就是我成功应用的一系列流程

239
00:24:06,640 --> 00:24:09,452
每当我把更新推送到 github

240
00:24:09,800 --> 00:24:16,100
然后 Travis CI 这个在云端的持续构建系统就会
获取一个包含打包系统的 docker 容器

241
00:24:16,100 --> 00:24:19,000
在这里是 CentOS 6

242
00:24:19,000 --> 00:24:24,310
这个系统里面包含了所有预装的依赖

243
00:24:24,310 --> 00:24:28,569
然后在云端把应用打包成 AppImage

244
00:24:28,850 --> 00:24:34,875
再把它上传到 BinTray

245
00:24:34,875 --> 00:24:36,610
BinTray 是一个终端用户可以下载的网站

246
00:24:36,610 --> 00:24:44,856
我们可以把这个网址链接到 AppImage 上

247
00:24:49,030 --> 00:24:56,770
每当有人在 github 上推送提交后
都能得到一个新的可运行的二进制文件

248
00:24:56,770 --> 00:25:05,890
你可以在 https://github.com/probonopd/ 上查看这个过程

249
00:25:05,890 --> 00:25:13,450
然后你就能看到我之前描述的
有一些软件

250
00:25:13,450 --> 00:25:19,330
已经打包好了 比如 MuseScore 和 Scribus
请随意将这套流程

251
00:25:21,550 --> 00:25:25,270
应用于其他构建系统或者其他基础服务

252
00:25:25,270 --> 00:25:31,990
我希望更多人能接受并使用它
如果你对此感兴趣我们非常欢迎 那么如何为 AppImage 做贡献呢

253
00:25:31,990 --> 00:25:36,100
首要途径就是大力宣传 AppImage
让人们意识到

254
00:25:36,100 --> 00:25:40,900
这是一套行之有效的解决方案

255
00:25:40,900 --> 00:25:46,480
更好的办法是建议你喜欢的程序的

256
00:25:46,480 --> 00:25:52,900
上游社区讨论使用 AppImage 进行打包

257
00:25:52,900 --> 00:25:57,880
理想情况下社区可能会信心十足地直接采用 AppImage 打包

258
00:25:57,880 --> 00:26:02,440
甚至以后都这样打包发布
也有可能他们

259
00:26:02,440 --> 00:26:08,380
会在拿一些项目练手打包测试之后放弃发布打包后的成品

260
00:26:08,380 --> 00:26:12,820
那真是太遗憾了
本可以很容易地做出一个更适应未来的精品应用

261
00:26:16,630 --> 00:26:21,220
请向你最爱的上游软件社区建议
打包一个 AppImage 格式应用

262
00:26:21,220 --> 00:26:26,170
但请注意 测试仍是必要的

263
00:26:26,170 --> 00:26:31,570
请在各种主流发行版上进行调试
直至令人满意

264
00:26:34,780 --> 00:26:42,660
你才能把 AppImage 的包整合进主要的基础软件设施中

265
00:26:42,660 --> 00:26:49,090
对于你自己的资源控制管理来说
我之前给出的例子就是采用 github 或者

266
00:26:52,380 --> 00:27:01,180
Travis CI或者docker或者以二进制包的形式来适配你的打包流程

267
00:27:01,180 --> 00:27:05,650
最终你会为AppImage项目本身做出贡献
比如一个可以自动生成AppImage的工具集

268
00:27:05,650 --> 00:27:10,960
现在有一个很好的例子
就是AppImage更新工具

269
00:27:10,960 --> 00:27:14,350
还处在概念验证状态而且有点简陋和粗糙
在这方面我们急需更多的帮助

270
00:27:16,990 --> 00:27:23,710
当遇到疑问时
请立即在github提交issue 大概就这么多 非常感谢您的观看！

271
00:27:23,710 --> 00:27:36,630
翻译团队名单 策划/组织-小鸡 翻译-AliveGh0st/冷清°

