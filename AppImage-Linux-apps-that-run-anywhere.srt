1
00:00:00,380 --> 00:00:01,125
AppImage 中文社区制作 感谢收看！

2
00:00:01,125 --> 00:00:03,200
本篇介绍 AppImage

3
00:00:03,200 --> 00:00:06,000
它由 Simon Peter 开发 能使 Linux 应用随处运行

4
00:00:08,275 --> 00:00:12,059
AppImage 是一种用于分发上游提供

5
00:00:12,059 --> 00:00:13,488
的应用二进制文件的格式

6
00:00:14,150 --> 00:00:17,100
这让用户可以轻松地获取和运行

7
00:00:17,100 --> 00:00:20,350
最新版本的 Linux 应用程序

8
00:00:21,050 --> 00:00:23,025
甚至那些只包含 stable 软件的系统都能运行
（例如 Debian Stable 和 CentOS）

9
00:00:23,025 --> 00:00:25,425
这意味着软件包不会以任何形式

10
00:00:25,425 --> 00:00:30,275
干扰基础系统所安装的依赖库

11
00:00:30,275 --> 00:00:33,510
换句话说 当你下载一个 AppImage 文件后

12
00:00:33,510 --> 00:00:35,768
它不会影响你的基础系统

13
00:00:36,525 --> 00:00:40,650
也使得上游软件开发方为 Linux 提供

14
00:00:40,650 --> 00:00:44,640
正式版和每日构建版或连续构建版变得很容易

15
00:00:44,950 --> 00:00:49,150
就像以前他们倾向于为 Mac OS 和 Windows 提供这些

16
00:00:49,150 --> 00:00:51,606
但很多时候不为 Linux 提供

17
00:00:51,814 --> 00:00:54,875
现在有了 AppImage 实现起来就很容易了

18
00:00:55,350 --> 00:01:01,725
并且我认为
通过我所说的软件开发流水线化可加快测试速度

19
00:01:02,065 --> 00:01:06,225
这让发布 下载 测试和制作都变得非常方便

20
00:01:06,500 --> 00:01:09,200
也让制作周期变得更短

21
00:01:10,075 --> 00:01:13,375
并且 AppImage 不需要任何中间机构

22
00:01:13,850 --> 00:01:17,310
如果用软件源这类

23
00:01:17,310 --> 00:01:24,450
你还得考虑的是如何把你的开源软件弄进软件源

24
00:01:24,725 --> 00:01:29,970
现在你可以为你的最终用户直接提供你的应用

25
00:01:29,970 --> 00:01:34,275
你和你最终用户之间的没有任何第三方

26
00:01:37,000 --> 00:01:39,350
简单自我介绍一下 我是 Simon

27
00:01:39,350 --> 00:01:43,098
我是一名 OS X 和 Linux live 系统用户

28
00:01:43,625 --> 00:01:47,075
我不是一个真正的应用程序开发人员

29
00:01:47,075 --> 00:01:51,000
但我已经跨界写代码超过十年了

30
00:01:51,000 --> 00:01:52,900
我从一个小的 UI 项目开始

31
00:01:52,900 --> 00:01:55,125
它涉及到便携式 Linux 应用程序

32
00:01:55,675 --> 00:01:57,975
后来终于开始做 AppImage

33
00:02:00,225 --> 00:02:03,475
以前来自社区的反馈不太好

34
00:02:03,475 --> 00:02:05,875
所以我曾经几乎放弃这个想法

35
00:02:05,875 --> 00:02:08,024
但我终于超越了自己

36
00:02:08,024 --> 00:02:08,025
视频后面我回过头来还要再谈这点

37
00:02:08,025 --> 00:02:11,734
视频后面我回过头来还要再谈这点

38
00:02:12,950 --> 00:02:15,575
现在让我们来阐述一个问题

39
00:02:15,963 --> 00:02:20,050
那就是今天我们打包和分发

40
00:02:20,050 --> 00:02:23,450
Linux 应用的方式并不方便

41
00:02:24,600 --> 00:02:26,875
所以让我们开始吧

42
00:02:29,300 --> 00:02:35,150
作为一个用户 我想从原始作者那里下载一个应用程序

43
00:02:35,615 --> 00:02:38,650
并且软件发布一发布我就想让它在 Linux 上运行

44
00:02:39,075 --> 00:02:42,750
就像 Windows 或 Mac 应用程序一样简单

45
00:02:43,375 --> 00:02:45,875
但目前对于 Linux 应用程序来说

46
00:02:46,550 --> 00:02:50,575
想做到这一点并不容易 是吧

47
00:02:50,575 --> 00:02:51,809
你们都体会到了

48
00:02:54,000 --> 00:02:57,725
如果你现在去你最喜欢的应用的下载页面

49
00:02:57,725 --> 00:03:00,560
可能你会找到它的

50
00:03:01,175 --> 00:03:04,125
Mac 或 Windows 版的下载链接

51
00:03:04,850 --> 00:03:07,475
但对于 Linux 你只能看到一堆乱七八糟的

52
00:03:07,475 --> 00:03:11,375
命令和代码仓库的链接

53
00:03:11,375 --> 00:03:13,730
没有给 Linux 简单方便地下载

54
00:03:13,730 --> 00:03:16,725
运行的方法

55
00:03:17,050 --> 00:03:18,707
如果你不相信我

56
00:03:18,707 --> 00:03:26,550
那现在就尝试从官网来下载 VLC 这个软件

57
00:03:26,550 --> 00:03:28,862
这样你就会知道我在说什么

58
00:03:31,850 --> 00:03:35,325
但是 如果换成使用 AppImage 格式将完全不同

59
00:03:35,325 --> 00:03:37,875
你只需要下载一个文件

60
00:03:38,119 --> 00:03:41,625
给予其可执行权限 通过一点点命令

61
00:03:41,625 --> 00:03:42,700
或者像我这样通过 GUI 界面操作

62
00:03:43,375 --> 00:03:45,530
就能直接运行它了

63
00:03:45,530 --> 00:03:50,825
我们不需要软件仓库 也不需要折腾

64
00:03:51,175 --> 00:03:57,100
只需要从应用程序原作者那里下载一个文件就能运行它了

65
00:03:59,825 --> 00:04:02,600
假设我是一名应用程序开发者

66
00:04:03,150 --> 00:04:07,103
我想为 Linux 桌面系统提供软件包

67
00:04:07,103 --> 00:04:12,275
但不必为每一个 Linux 发行版

68
00:04:12,275 --> 00:04:14,525
都进行编译

69
00:04:16,543 --> 00:04:19,167
你可能认为这有点扯

70
00:04:19,167 --> 00:04:22,850
但是 一旦你试图把你的应用程序

71
00:04:22,850 --> 00:04:22,860
发布到每一个发行版中去

72
00:04:22,860 --> 00:04:25,075
发布到每一个发行版中去

73
00:04:25,075 --> 00:04:28,425
这里我只是列出常见的几个系统

74
00:04:28,925 --> 00:04:31,227
这时你就会明白我在说什么了

75
00:04:31,650 --> 00:04:37,750
当然你也能等应用打包者们打包你的应用

76
00:04:37,750 --> 00:04:39,650
不过等到那时

77
00:04:39,650 --> 00:04:42,725
可能你的程序已经更新了 5 个版本了

78
00:04:43,000 --> 00:04:48,102
这真的不是一个便捷快速的方法

79
00:04:50,025 --> 00:04:55,975
这段话应该很多人都知道对吧

80
00:04:55,975 --> 00:05:00,000
Linus Trovalds 在 DebConf 2014

81
00:05:00,000 --> 00:05:02,735
会议上的一段话

82
00:05:03,650 --> 00:05:05,400
他这么说的

83
00:05:06,300 --> 00:05:09,625
我们基本上不会为 Linux 应用程序制作二进制文件

84
00:05:10,258 --> 00:05:16,679
因为给 Liunx 桌面程序制作二进制文件 比被爆菊还难受

85
00:05:16,679 --> 00:05:19,225
你可能刚刚为 Fedora 19 制作完二进制文件

86
00:05:19,900 --> 00:05:22,750
接着又要为 Fedora 20 重新制作二进制文件

87
00:05:22,750 --> 00:05:26,175
甚至可能需要为 RHEL 5 这样十年前的

88
00:05:26,175 --> 00:05:28,050
系统制作二进制文件

89
00:05:28,050 --> 00:05:32,035
还有 Debian stable 等等等等（想想就头大）

90
00:05:32,035 --> 00:05:36,575
也许我应该在这里插入 Linus 说这句话的视频

91
00:05:40,250 --> 00:05:42,225
另一个例子 作为测试者

92
00:05:42,225 --> 00:05:51,610
我想同时运行 Jenkins 或 Travis CI 进行快速且有条不紊的连续构建项目

93
00:05:54,800 --> 00:05:58,225
看下我们的解决方案

94
00:05:59,825 --> 00:06:03,350
首先，我们的目标是什么

95
00:06:04,650 --> 00:06:07,275
它应该是简单的

96
00:06:08,125 --> 00:06:11,369
其次 它还应该保持二进制兼容性

97
00:06:11,369 --> 00:06:14,735
如果不能变成可以在你的系统上运行的二进制文件

98
00:06:14,735 --> 00:06:18,875
那么即便是最伟大的源代码也无济于事

99
00:06:19,575 --> 00:06:22,600
最后 它也应该拥有很好的兼容性

100
00:06:24,315 --> 00:06:24,468
我们的解决方案是

101
00:06:24,468 --> 00:06:25,860
我们的解决方案是

102
00:06:25,860 --> 00:06:32,025
它不需要在任何发行版做特别的依赖支持

103
00:06:32,025 --> 00:06:35,850
所以应该保证这个解决方案能在

104
00:06:35,850 --> 00:06:38,875
当今绝大多数的 Linux 发行版上运行

105
00:06:40,425 --> 00:06:45,199
我们也想完全跳过安装这一必须步骤

106
00:06:45,525 --> 00:06:50,450
例如 如果你使用像 LibreOffice 这样的大型应用程序

107
00:06:50,850 --> 00:06:53,800
但你不想非得先安装它

108
00:06:53,800 --> 00:06:57,211
感觉这很像 Windows 95 对吧

109
00:06:57,211 --> 00:07:02,525
你要下载然后安装，并傻傻的看着进度条

110
00:07:02,825 --> 00:07:05,462
从左边移动到右边

111
00:07:05,462 --> 00:07:08,875
我希望完全消除安装的过程

112
00:07:08,875 --> 00:07:11,300
换一种说法

113
00:07:11,575 --> 00:07:19,775
应用程序在下载完的时候和在运行他的时侯应该是一模一样的

114
00:07:20,250 --> 00:07:23,883
这也意味着我们可以一直保持应用程序压缩着

115
00:07:23,883 --> 00:07:27,211
我们不必解包或解压缩应用程序

116
00:07:27,725 --> 00:07:31,102
这个工作在运行程序时就已经悄悄做好了

117
00:07:32,350 --> 00:07:37,025
我们的设计也允许我们把应用程序放在任何地方

118
00:07:37,629 --> 00:07:40,253
换一种说法就是，它是绿色软件

119
00:07:40,625 --> 00:07:44,125
这可以允许你把应用程序放在USB存储设备中

120
00:07:44,125 --> 00:07:46,000
并让你很方便的带走它

121
00:07:47,050 --> 00:07:50,327
应用程序是只读的

122
00:07:50,327 --> 00:07:51,150
这意味着你必须确保

123
00:07:51,150 --> 00:07:58,986
你已经下载的应用程序 100% 不会以任何方式改变自身

124
00:08:00,450 --> 00:08:06,111
在制作这些软件包的时候也应该考虑到这些

125
00:08:06,111 --> 00:08:09,311
即使我们没有应用程序全部的源代码

126
00:08:09,311 --> 00:08:15,775
应该也可以用这种方式来封装应用程序

127
00:08:16,900 --> 00:08:21,424
我们还希望保持基础操作系统的纯洁

128
00:08:21,775 --> 00:08:23,125
这不仅意味着

129
00:08:23,125 --> 00:08:25,383
你只是下载并运行一个软件

130
00:08:25,383 --> 00:08:29,863
而且它不会改变你的系统依赖库

131
00:08:30,250 --> 00:08:31,250
这同时也意味着

132
00:08:31,750 --> 00:08:36,600
运行以这种方式打包的应用程序时

133
00:08:36,971 --> 00:08:43,625
不会有任何运行时或二进制文件需要被安装

134
00:08:43,625 --> 00:08:46,617
在我们开始使用这个系统之前

135
00:08:47,513 --> 00:08:50,975
最后 这一切都不应该需要 root 权限

136
00:08:51,850 --> 00:08:55,382
所以创建这样一个体系是可能的吗

137
00:08:56,400 --> 00:08:59,200
当然 接下来是一些核心理念

138
00:09:00,425 --> 00:09:03,425
我们的核心理念是 

139
00:09:03,700 --> 00:09:08,100
一个软件等于一个文件

140
00:09:08,350 --> 00:09:12,600
这让我们管理软件变得很容易

141
00:09:12,600 --> 00:09:16,900
不需要任何包管理器和复杂的系统

142
00:09:17,500 --> 00:09:21,225
如果你要记住这段视频的一句话的话 

143
00:09:21,225 --> 00:09:27,125
那就是 Appimage 致力于让一个软件等于一个文件

144
00:09:28,000 --> 00:09:33,525
当然 这个单文件不需要包含这个软件

145
00:09:33,525 --> 00:09:36,450
运行所需的所有东西

146
00:09:36,450 --> 00:09:45,296
只要包含那些我们无法有理有据地假设其存在的东西

147
00:09:45,575 --> 00:09:46,575
这就意味着

148
00:09:46,575 --> 00:09:52,391
除了那些一般发行版都预装的以外

149
00:09:52,391 --> 00:09:57,175
其实 AppImage 是包含所有需要的组件的

150
00:09:59,700 --> 00:10:02,119
另一个关于AppImage的核心理念是

151
00:10:02,119 --> 00:10:06,300
我们不允许包含任何

152
00:10:06,300 --> 00:10:12,120
我们认为已经包含在系统里的组件

153
00:10:12,120 --> 00:10:16,174
只要我们认为某些合适的依赖库

154
00:10:16,174 --> 00:10:19,450
已包含在主流发行版中 

155
00:10:19,450 --> 00:10:24,250
我们就不必包含在 AppImage 内

156
00:10:24,550 --> 00:10:26,650
但是觉得异议的话

157
00:10:26,650 --> 00:10:26,670
那我们就会包含进去

158
00:10:26,670 --> 00:10:28,525
那我们就会包含进去

159
00:10:30,870 --> 00:10:33,000
还有一个打包 AppImage 的核心思想是

160
00:10:33,000 --> 00:10:39,000
打包并分发给你的用户应该是直接地

161
00:10:39,000 --> 00:10:44,325
而不被任何中间机构比如 Repo 那样的东西挡在你

162
00:10:44,325 --> 00:10:48,794
也就是作者跟用户之间

163
00:10:49,275 --> 00:10:54,525
别的系统中也利用了这个成功的模式

164
00:10:54,800 --> 00:11:01,300
有的系统还有应用商店认为你能自己判断 

165
00:11:01,300 --> 00:11:09,950
但我还是认为应用的作者和用户之间不应有任何媒介

166
00:11:10,300 --> 00:11:12,900
最终一个核心思想 极简致胜

167
00:11:13,425 --> 00:11:16,325
为此 我们去掉了所有复杂的东西

168
00:11:16,325 --> 00:11:18,305
并且达到最大化的精简 

169
00:11:21,075 --> 00:11:23,295
那什么是 AppImage 呢

170
00:11:24,350 --> 00:11:27,800
AppImage 是我谈到过的单文件应用程序

171
00:11:27,800 --> 00:11:35,625
实际上你可以把应用的每一个版本都弄成一个的单文件

172
00:11:35,625 --> 00:11:37,775
它们能够共存

173
00:11:38,225 --> 00:11:40,800
应用的镜像包含两部分

174
00:11:41,250 --> 00:11:45,062
第一部分是一些少量的可执行头部

175
00:11:45,650 --> 00:11:50,475
第二部分包含应用的主体的磁盘镜像

176
00:11:51,475 --> 00:11:56,370
现在 引导程序是一个常规的 ELF 二进制文件

177
00:11:56,370 --> 00:11:58,875
一个 Linux 可执行的二进制文件

178
00:11:58,875 --> 00:12:01,421
用来挂载磁盘镜像

179
00:12:01,650 --> 00:12:06,167
然后执行这个磁盘镜像的可执行文件

180
00:12:06,800 --> 00:12:09,875
这是通过 fuse 挂载的

181
00:12:09,875 --> 00:12:14,325
也就是说 你不需要用 root 权限挂载 AppImage

182
00:12:18,120 --> 00:12:24,660
这个磁盘镜像本身是一个常规的 ISO 文件
它同时也被压缩了 可以每个 Linux 发行版

183
00:12:24,660 --> 00:12:29,580
都有的标准内核的方法挂载
如果你想深入查看磁盘镜像

184
00:12:29,580 --> 00:12:34,709
只需要用loop参数挂载 就能查看它包含的内容

185
00:12:38,520 --> 00:12:44,640
磁盘镜像包含了你的应用的 payload
也就是应用程序和依赖

186
00:12:44,640 --> 00:12:53,890
AppDir 是什么呢
应用目录（Applycation Directory）

187
00:12:53,890 --> 00:13:01,000
应用目录是一个文件系统树

188
00:13:01,000 --> 00:13:07,720
我们所假设的基本系统所不包含的依赖

189
00:13:07,720 --> 00:13:13,750
另外有一个文件叫 AppRun
这是程序的主入口点

190
00:13:13,750 --> 00:13:23,079
这就是当你运行 AppImage 时运行的程序

191
00:13:23,079 --> 00:13:29,440
创建 AppDir 时你应该时刻记住 AppDir 必须

192
00:13:29,440 --> 00:13:35,230
不依赖那些不是你所有的目标平台中都有的东西

193
00:13:35,230 --> 00:13:42,880
最实际的做法是

194
00:13:42,880 --> 00:13:48,190
在一个比最老的目标平台还要老旧
的平台来编译你的应用

195
00:13:50,175 --> 00:13:58,525
然后将所有目标系统中缺少的文件
打包到 AppImage 文件中

196
00:14:00,450 --> 00:14:02,550
我还有一些其它的想法

197
00:14:03,525 --> 00:14:05,262
比如软件的更新方式

198
00:14:06,525 --> 00:14:12,925
如果我们我们有一个约 100 兆的 AppImage
假设我们为这个软件做每日构建版本

199
00:14:13,300 --> 00:14:22,980
如果每天都需要去下载那个 100 多兆大的文件
那可不太妙

200
00:14:23,850 --> 00:14:30,598
所以利用增量升级的方法
我们只需下载应用中发生变化的部分

201
00:14:30,598 --> 00:14:33,198
在实际应用中 需要重新下载的部分不会很多

202
00:14:33,198 --> 00:14:35,924
我对一大批应用进行过这方面的测试

203
00:14:36,975 --> 00:14:39,263
对很多应用而言
只需要下载差不多约 2 兆大小的文件

204
00:14:39,263 --> 00:14:42,370
就可以完成从一个每日构建版本到另一个的升级

205
00:14:42,370 --> 00:14:44,250
这种方法在实际应用中切实有效

206
00:14:44,575 --> 00:14:48,276
我在这里给出一个链接供您亲自尝试

207
00:14:48,925 --> 00:14:52,025
下一个想法是使用沙箱技术

208
00:14:52,800 --> 00:14:58,750
沙箱技术不仅让应用更易于运行
还让运行应用在某种程度上变得更加安全

209
00:14:58,750 --> 00:15:03,375
比方说将应用限制在一个只读文件系统中

210
00:15:03,375 --> 00:15:05,459
它便不能进行一些恶意行为

211
00:15:05,459 --> 00:15:09,050
例如删除你的 home 目录下的文件
或者其他类似行为

212
00:15:09,725 --> 00:15:14,325
我已经针对这个想法进行了一些实验

213
00:15:14,950 --> 00:15:18,525
最后 我们也希望与构建系统有机结合

214
00:15:19,948 --> 00:15:29,625
使得制作 AppImage 最终和编译普通软件一样简单

215
00:15:29,901 --> 00:15:33,676
为了实现这个目标 我们计划将 AppImageKit 与构建系统结合起来

216
00:15:34,025 --> 00:15:38,250
不过现在我必须说 我并不是一个精通编译系统的人

217
00:15:38,250 --> 00:15:42,925
所以如果有人在这个领域有开发经验 请来联系我

218
00:15:42,925 --> 00:15:48,950
我们可以一起完成将 AppImageKit 与构建系统结合的任务

219
00:15:50,675 --> 00:15:53,925
以上是我的想法

220
00:15:53,925 --> 00:15:56,325
正如我前面所说的

221
00:15:56,800 --> 00:15:58,562
十年多的时间 我一直在做这个项目

222
00:15:59,150 --> 00:16:00,375
那些反对意见又是怎样的呢

223
00:16:00,375 --> 00:16:03,703
事实上 有各种各样的反对的声音混杂在一起

224
00:16:03,703 --> 00:16:06,500
这里是一些典型的意见

225
00:16:07,900 --> 00:16:11,025
"这个工具的存在是多此一举"

226
00:16:12,050 --> 00:16:18,350
一些没看到 AppImage 作为系统包管理器补充的必要性的用户

227
00:16:18,350 --> 00:16:20,260
经常发出这样的反对声音

228
00:16:20,260 --> 00:16:23,442
我们来看看另一个

229
00:16:23,442 --> 00:16:30,610
我们来看看另一个

230
00:16:30,610 --> 00:16:35,319
"如果某个玩意儿是开源的 我们就不需要这个东西
打包者打包完了或者必要时传输需要的库就行了"

231
00:16:35,319 --> 00:16:42,459
好吧 也许是这样 你可以试试

232
00:16:42,459 --> 00:16:47,319
下载喜欢的软件的最新版本 我们来试试 Krita 3.0

233
00:16:47,319 --> 00:16:53,380
前几天才发布的 你会发现 如果你用的不是 CentOS 6.0 的话

234
00:16:53,380 --> 00:16:58,529
会很难用得上

235
00:17:00,000 --> 00:17:06,040
另一个是
"尽管可能很酷"
"但这样分发应用将会是安全噩梦"

236
00:17:06,040 --> 00:17:11,849
好的 我从两个方面分析 第一个

237
00:17:11,849 --> 00:17:11,850
当我从原作者那里下载些东西时

238
00:17:11,850 --> 00:17:17,399
当我从原作者那里下载些东西时

239
00:17:17,400 --> 00:17:22,650
也就是说我相信这个软件和他的作者
否则我压根不会去运行

240
00:17:22,650 --> 00:17:32,910
至少对我来说 我更喜欢运行从源头获取的软件

241
00:17:32,910 --> 00:17:37,290
相比之下 从那些中间人那里获取的
你永远不知道他们对原文件做了什么

242
00:17:39,450 --> 00:17:46,530
不论那些是否经过原作者同意的更改
第二个是

243
00:17:46,530 --> 00:17:51,050
我们没有“沙箱” 但是像我提到的

244
00:17:51,050 --> 00:17:56,970
我正在实验提供一个可选的沙箱来运行程序

245
00:17:56,970 --> 00:18:05,880
比如说在一个只读的限制环境之类的

246
00:18:05,880 --> 00:18:12,600
然后收到这些反馈后的很长很长一段时间
我几乎要放弃给 Linux 打包软件这个想法了

247
00:18:17,250 --> 00:18:23,160
我还觉得这跟文化很有关系
这种东西在 OS 10 一直很不错

248
00:18:23,160 --> 00:18:28,530
而且 Apple 世界里经过多年的考验

249
00:18:28,530 --> 00:18:32,400
看起来 linux 用户有些不同
他们居然不赞同这个点子

250
00:18:32,400 --> 00:18:41,220
直到那时
这是引用 Linus Torvalds 说的

251
00:18:41,220 --> 00:18:47,190
他试用了 AppImage
得出的结论是 ”这玩意儿超酷"

252
00:18:47,190 --> 00:18:52,260
实际上你进入屏幕下方的链接

253
00:18:52,260 --> 00:18:57,900
那是很长的讨论 其中涉及前面提到的和没有提到的很多观点

254
00:18:57,900 --> 00:19:07,500
最后 Linus 确实证实了 AppImage 和 AppImagekit 的理念 最好读一读

255
00:19:09,475 --> 00:19:10,675
其他人也赞同这一点

256
00:19:10,675 --> 00:19:14,125
比如一个现任的 subsurface 项目的维护者

257
00:19:14,125 --> 00:19:17,606
他说 "AppImage 确实非常非常有用"

258
00:19:19,590 --> 00:19:25,149
从那开始很多开源软件开始采用 AppImage

259
00:19:25,400 --> 00:19:26,525
例如 krita（免费开源的绘图软件）

260
00:19:26,525 --> 00:19:28,700
现在在他们的下载页面提供 AppImage 版本

261
00:19:29,123 --> 00:19:33,700
就像他们给 Windows 和 Mac 上提供的一致

262
00:19:35,225 --> 00:19:40,775
还有 scribus 项目 一个开源电子杂志制作软件

263
00:19:40,775 --> 00:19:46,600
同样在下载页面为 Linux 提供了 AppImage
甚至为候选版本提供了 AppImage 下载

264
00:19:47,900 --> 00:19:54,600
Musescore 音乐软件
现在不仅为 64 位系统提供 AppImage

265
00:19:54,600 --> 00:19:59,969
而且也为 32 位系统提供 AppImage
甚至为 ARM 系统提供

266
00:19:59,969 --> 00:20:03,675
所以你甚至可以在你的手机
平板电脑或者树莓派上运行它

267
00:20:06,825 --> 00:20:10,114
那么怎样才能制作一个 AppImage 呢

268
00:20:12,550 --> 00:20:15,359
它真的不是那么复杂

269
00:20:16,025 --> 00:20:21,549
在这里我展示了一个小小的 helloworld 示例
重新包装现有的二进制文件

270
00:20:21,549 --> 00:20:27,825
在这里我把下好的 leafpad（linux 下一款轻量级编辑器）的 deb 软件包

271
00:20:28,250 --> 00:20:32,014
转换成为了一个 AppImage 包

272
00:20:32,275 --> 00:20:39,350
我做的第一件事是为 leafpad 建立一个 AppDir 目录

273
00:20:40,525 --> 00:20:47,049
然后下载 deb 软件包 接下来进入 AppDir 目录

274
00:20:48,450 --> 00:20:54,950
解压 deb 包
复制图标文件和桌面链接文件到 AppDir 的根目录之后

275
00:20:54,950 --> 00:21:03,675
从 AppImagekit 获取 AppRun 文件

276
00:21:04,025 --> 00:21:08,919
重复一下
AppRun 文件是进入 AppDir 的主入口点

277
00:21:08,919 --> 00:21:15,149
我以前谈过这个 它的作用是启动应用程序

278
00:21:15,800 --> 00:21:24,399
最后我退出 AppDir 目录
下载 AppImageassistant

279
00:21:24,399 --> 00:21:27,639
用它将 AppDir 转换成 AppImage
这真的很简单

280
00:21:27,639 --> 00:21:29,725
结果便是一个可以运行的 AppImage

281
00:21:30,450 --> 00:21:40,545
在这个例子中
至少是一个可以运行在打包系统或更新的系统的 AppImage

282
00:21:40,545 --> 00:21:49,100
所以在一个你能得到的最旧的发行版上编译二进制文件比较好

283
00:21:51,750 --> 00:21:57,225
在现实世界中 你想做的可能不只是

284
00:21:57,659 --> 00:21:59,850
重新打包已有的二进制软件

285
00:21:59,850 --> 00:22:03,659
但是在自己构建的时候

286
00:22:03,659 --> 00:22:05,359
正如我说的 最好使用一个足够老的系统

287
00:22:06,250 --> 00:22:10,175
最好是你能够找到的最老的

288
00:22:10,175 --> 00:22:14,550
但是仍然有现成的编译器和构建工具的版本

289
00:22:15,300 --> 00:22:19,225
比方说我已经在 Centos 6 上成功过了

290
00:22:19,950 --> 00:22:24,925
此外要保证你打包的应用没有硬编码路径

291
00:22:25,600 --> 00:22:32,075
否则你要在源码甚至二进制文件上打上补丁

292
00:22:33,400 --> 00:22:37,150
剩下要做的就和前面我所说的一样了

293
00:22:37,700 --> 00:22:40,275
把你的应用转换成 AppDir

294
00:22:40,700 --> 00:22:49,400
并且你应该把各个需要调用的库也打包进 AppDir 里面

295
00:22:49,400 --> 00:22:55,108
也就是说如果你的应用调用了一个非常新的库

296
00:22:55,525 --> 00:23:01,575
你必须把这个库包含到 AppImage 中

297
00:23:02,340 --> 00:23:06,925
最后当你成功构建出你的应用镜像 请在各个发行版进行测试

298
00:23:06,925 --> 00:23:11,460
不要忽略这重要的一步

299
00:23:11,460 --> 00:23:19,400
我用各种 Linux live ISO 来测试

300
00:23:19,400 --> 00:23:22,550
这样可以很方便地切换到各种系统进行测试

301
00:23:26,000 --> 00:23:32,100
当你可以连续构建的时候 你会发现这是非常有趣的

302
00:23:32,825 --> 00:23:41,325
连续构建指的是每当有人提交了变更 你都可以自动化的构建你的软件

303
00:23:42,123 --> 00:23:51,907
如果你可以做到那样 那么你就可以在很短的时间内完成你的打包工作

304
00:23:51,907 --> 00:23:55,969
这将大大增加打包的效率

305
00:23:56,275 --> 00:24:00,225
想象一下这就像 Git 一样

306
00:24:03,125 --> 00:24:06,640
下面这就是我成功应用的一系列流程

307
00:24:06,640 --> 00:24:09,452
每当我把更新推送到 github

308
00:24:09,800 --> 00:24:16,100
然后 Travis CI 这个在云端的持续构建系统就会
获取一个包含打包系统的 docker 容器

309
00:24:16,100 --> 00:24:19,000
在这里是 CentOS 6

310
00:24:19,000 --> 00:24:24,310
这个系统里面包含了所有预装的依赖

311
00:24:24,310 --> 00:24:28,569
然后在云端把应用打包成 AppImage

312
00:24:28,850 --> 00:24:34,875
再把它上传到 BinTray

313
00:24:34,875 --> 00:24:36,610
BinTray 是一个终端用户可以下载的网站

314
00:24:36,610 --> 00:24:44,856
我们可以把这个网址链接到 AppImage 上

315
00:24:49,030 --> 00:24:56,770
这全都是自动完成的 每当有人在 github 上推送提交后
都能得到一个新的可运行的二进制文件

316
00:24:56,770 --> 00:25:05,890
你可以在 https://github.com/probonopd/ 上查看这个过程

317
00:25:05,890 --> 00:25:13,450
然后你就能看到我之前描述的过程

318
00:25:13,450 --> 00:25:19,330
有一些软件已经这么做了 比如 MuseScore 和 Scribus
请随意将这套流程

319
00:25:21,550 --> 00:25:25,270
应用于其他构建系统或者其他基础服务

320
00:25:25,270 --> 00:25:31,990
我很期待你会怎么搞
那么如何为 AppImage 做贡献呢

321
00:25:31,990 --> 00:25:36,100
首要途径就是大力宣传 AppImage
让人们意识到

322
00:25:36,100 --> 00:25:40,900
这是一套行之有效的解决方案

323
00:25:40,900 --> 00:25:46,480
更好的办法是建议你喜欢的程序的

324
00:25:46,480 --> 00:25:52,900
上游社区讨论使用 AppImage 进行打包

325
00:25:52,900 --> 00:25:57,880
他们可能会信心十足地用 AppImage 手动打包

326
00:25:57,880 --> 00:26:02,440
他们可能也会用集成构建来做

327
00:26:02,440 --> 00:26:08,380
话说回来 现在一些项目都是测试完就把构建的版本扔掉

328
00:26:08,380 --> 00:26:12,820
本来可以成为史诗般的应用
就那么被丢掉了 真是太浪费了

329
00:26:16,630 --> 00:26:21,220
如果你想更进一步 可以向你最爱的上游软件社区提交 pull request
打包 AppImage 格式应用

330
00:26:21,220 --> 00:26:26,170
但请注意 测试仍是必要的

331
00:26:26,170 --> 00:26:31,570
请在各种主流发行版上进行调试
直至令人满意

332
00:26:34,780 --> 00:26:42,660
你也可以把打包过程整合到源码控制系统和构建设施中

333
00:26:42,660 --> 00:26:49,090
我之前给出的例子就是采用 "github"
"Travis CI" "docker" 和 "Bintray" 自动化打包流程

334
00:26:52,380 --> 00:27:01,180
你可以用你自己的一套

335
00:27:01,180 --> 00:27:05,650
最后你可以为 AppImage 项目本身做出贡献
也就是自动生成 AppImage 的工具集

336
00:27:05,650 --> 00:27:10,960
现在有一个很好的例子
AppImage 更新工具

337
00:27:10,960 --> 00:27:14,350
这还处在概念验证状态而且有点简陋和粗糙
在这方面我们急需更多的帮助

338
00:27:16,990 --> 00:27:23,710
当遇到疑问时 不要犹豫
请立即到 github.com/probonoPD/appimagkit 开个 issue
大概就这么多 非常感谢您的观看

339
00:27:23,710 --> 00:27:36,630
翻译团队名单 策划/组织-小鸡 翻译-AliveGh0st/冷清°

