1
00:00:00,380 --> 00:00:01,640
AppImage中文社区制作 感谢收看！

00:00:01,640 --> 00:00:05,640
本篇介绍AppImage
它由Simon Peter开发 能使Linux应用随处运行

2
00:00:05,640 --> 00:00:12,059
AppImage是一种用于分发上游提供
的应用二进制文件的格式

3
00:00:12,059 --> 00:00:17,580
这真的让用户可以轻松地获取和运行
Linux应用程序的最新版本

4
00:00:17,580 --> 00:00:23,250
并且甚至适用于稳定的基本系统
（例如Debian Stable和Cent OS）

5
00:00:23,250 --> 00:00:28,380
这意味着软件包不会以任何形式
干扰基础系统所安装的依赖库

6
00:00:28,380 --> 00:00:33,510
换句话说 当你下载一个AppImage文件后


7
00:00:33,510 --> 00:00:39,360
它不会影响你的基础系统 也使得上游
软件开发方为Linux提供

8
00:00:39,360 --> 00:00:44,640
正式版和每日构建版或连续构建版变得很容易


9
00:00:44,640 --> 00:00:50,969
就像以前他们倾向于为mac OS和Windows提供这些
但很多时候不为Linux提供

10
00:00:50,969 --> 00:00:55,980
现在有了AppImage 实现起来就真的很容易了
并且我认为通过我所说的软件开发流水线化可加快测试速度

11
00:00:59,160 --> 00:01:06,810
这确实易于发布、下载、测试和制作
制作周期真的快

12
00:01:06,810 --> 00:01:12,290
并且AppImage不需要任何中间媒介
13
00:01:12,290 --> 00:01:17,310
在分发或储存应用等的时候

14
00:01:17,310 --> 00:01:23,610
你首先要考虑的是如何让你制作的开源软件
进入软件源

15
00:01:23,610 --> 00:01:29,970
你可以提供你的应用到你的最终用户

16
00:01:29,970 --> 00:01:38,579
没有你和你最终用户之间的任何第三方

17
00:01:38,579 --> 00:01:42,720
自我介绍一下 我是Simon
我是一名OS X和Linux live系统用户

18
00:01:42,720 --> 00:01:49,649
我不是一个真正的应用程序开发人员
但我已经跨界写代码超过十年了

19
00:01:49,649 --> 00:01:54,270
我从一个小的UI项目开始
它涉及到便携式Linux应用程序

20
00:01:54,270 --> 00:02:01,729
后来终于开始做AppImage
以前来自社区的反馈不太好

21
00:02:01,729 --> 00:02:06,750
所以我曾经几乎放弃这个想法

22
00:02:06,750 --> 00:02:10,140
但我终于超越了自己
视频后面我回过头来还要再谈这点

23
00:02:10,139 --> 00:02:16,250
现在让我们来阐述一个问题

24
00:02:16,250 --> 00:02:21,019 
那就是今天我们打包和分发
Linux应用的方式并不方便

25
00:02:21,019 --> 00:02:32,209
所以让我们开始吧
作为一个用户，我想从原始作者那里下载一个应用程序

26
00:02:32,209 --> 00:02:37,819
并且在软件发布之日起我想让它在Linux上运行
就像Windows或Mac应用程序一样简单

00:02:40,640 --> 00:02:48,829
但目前对于Linux应用程序来说
想做到这一点并不容易 是吧

28
00:02:48,829 --> 00:02:51,230
你们都体会到了

29
00:02:55,310 --> 00:03:00,560
如果你现在去你最喜欢的应用的下载页面
可能你会找到它的

30
00:03:00,560 --> 00:03:08,709
Mac或Windows版的下载链接
但对于Linux 你只能看到一堆乱七八糟的

31
00:03:08,709 --> 00:03:13,730
命令和代码仓库的链接 
没有简单的方法去仅仅想下个软件包

32
00:03:13,730 --> 00:03:19,220
然后运行在Linux
如果你不相信我

33
00:03:19,220 --> 00:03:24,889
那现在就尝试从官网来下载VLC这个软件

34
00:03:24,889 --> 00:03:32,599
这样你就会知道我在说什么
但是 如果换成使用AppImage格式将完全不同

35
00:03:34,700 --> 00:03:40,669
你只需要下载一个文件 
给予其可执行权限 通过一点点命令

36
00:03:40,669 --> 00:03:45,530
或者像我这样通过GUI界面操作
最后你就能直接运行它了

37
00:03:45,530 --> 00:03:53,180
我们不需要软件仓库 也不需要折腾

38
00:03:53,180 --> 00:04:01,010
只需要从应用程序原作者那里下载一个文件你就能运行它了
现在有一名应用程序开发者

39
00:04:04,040 --> 00:04:09,739
他想为Linux桌面系统提供软件包
就没有必要为每一个Linux发行版

40
00:04:09,739 --> 00:04:13,700
进行数次编译
你可能认为这种事情只是理论上的

41
00:04:17,870 --> 00:04:22,860
但是，一旦你试图把你的应用程序

42
00:04:22,860 --> 00:04:27,449
发布到每一个发行版中去
那你一定只会发布几个最常用系统的包到下载页面

43
00:04:27,449 --> 00:04:32,610
这时你就会明白我在说什么了
当然如果你只是等待

44
00:04:32,610 --> 00:04:38,699
应用打包者们来打包你的应用
当那种可能发生时

45
00:04:38,699 --> 00:04:44,189
可能该应用程序已经更新了5个版本了

46
00:04:44,189 --> 00:04:53,699
这真的不是一个便捷快速的方法
这句话是为了提醒真正在乎的人

47
00:04:53,699 --> 00:04:58,949
Linus Trovalds在DebConf 2014
会议上说了一句话

48
00:04:58,949 --> 00:05:07,259
他这么说的

49
00:05:07,259 --> 00:05:12,780
我们基本上不会为Linux应用程序制作二进制文件
因为给Liunx桌面程序制作二进制文件 比被爆菊还难受

50
00:05:15,779 --> 00:05:21,210
你可能刚刚为Fedora19制作完二进制文件

51
00:05:21,210 --> 00:05:27,509
接着又要为fedora 20重新制作二进制文件
甚至可能需要为RHEL 5这样十年前的

52
00:05:27,509 --> 00:05:32,370
系统制作二进制文件
还有Debian的各个稳定版本等等（想想就头大） 

53
00:05:32,370 --> 00:05:41,550
也许我应该在这里插入Linus说这句话的视频

54
00:05:41,550 --> 00:05:47,460
另一个例子 作为测试者
我想同时运行Jenkins或Travis CI进行快速且有条不紊的连续构建项目

55
00:05:50,610 --> 00:06:05,400
所以，这就是我们的解决方案
首先，它应该是简单的

56
00:06:08,789 --> 00:06:13,830
其次 它还应该保持二进制兼容性
如果不能变成在可以你的系统上运行的二进制文件

57
00:06:13,830 --> 00:06:20,870
那么即便是最伟大的源代码也无济于事
最后 它也应该拥有很好的兼容性

58
00:06:20,870 --> 00:06:25,860
而且我们要比这个目标更近一步
我们的解决方案是

59
00:06:25,860 --> 00:06:30,409
它不需要在任何发行版做特别的依赖支持

60
00:06:30,409 --> 00:06:35,850
所以应该保证这个解决方案能在

61
00:06:35,850 --> 00:06:42,540
当今绝大多数的Linux发行版上运行
我们也想完全跳过安装这一必须步骤

62
00:06:42,540 --> 00:06:49,340
例如，如果你使用像LibreOffice这样的大型应用程序

63
00:06:52,350 --> 00:06:57,720
但你不想首先去安装它
感觉这很像Windows 95，对吧？

64
00:06:57,720 --> 00:07:02,300
你需要下载它，并安装它，并傻傻的看着进度条

65
00:07:02,300 --> 00:07:07,770
从左边移动到右边
我希望完全消除安装的过程 

66
00:07:09,660 --> 00:07:17,070
换一种说法
在下载应用程序的时候和在运行他的时侯应该是一模一样的

67
00:07:19,260 --> 00:07:22,290
这也意味着我们可以随时保持应用程序的压缩性

68
00:07:22,290 --> 00:07:27,960
我们不必压缩或解压缩应用程序
这个工作在运行程序时就已经悄悄做好了

69
00:07:31,850 --> 00:07:38,580
我们的设计也允许我们把应用程序放在任何地方
换一种说法就是，它是绿色软件

70
00:07:41,280 --> 00:07:47,780
这可以允许你把应用程序放在USB存储设备中
并让你很方便的带走它

71
00:07:47,780 --> 00:07:52,560
应用程序是只读的
这意味着你必须确保

72
00:07:52,560 --> 00:07:58,140
你已经下载的应用程序100%不会以任何方式改变自身

73
00:07:58,140 --> 00:08:06,480
在制作这些软件包的时候也应该考虑到这些

74
00:08:06,480 --> 00:08:10,950
即使我们没有应用程序全部的源代码
应该也可以用这种方式来封装应用程序

75
00:08:13,170 --> 00:08:22,140
我们还希望保持基础操作系统的纯洁
这不仅意味着

76
00:08:23,910 --> 00:08:29,040
你只是下载并运行一个软件
而且它不会改变你的系统依赖库

77
00:08:29,040 --> 00:08:35,729
这同时也意味着 不应该有任何运行时
或二进制文件

78
00:08:35,729 --> 00:08:43,229
需要被安装 


79
00:08:43,229 --> 00:08:49,050
在我们开始使用这个系统之前
最后，这一切都不应该需要root权限。


80
00:08:52,110 --> 00:09:01,320
所以创建这样一个体系是可能的吗
当然，接下来是一些核心理念。

81
00:09:01,320 --> 00:09:07,170
我们的核心理念是，一个软件等于一个文件


82
00:09:09,630 --> 00:09:14,670
这让我们管理软件变得很容易


83
00:09:14,670 --> 00:09:20,460
不需要任何包管理器和复杂的系统


84
00:09:20,460 --> 00:09:26,130
如果你要记住这段视频的一句话的话，我们的理念就是
一个软件等于一个文件


85
00:09:26,130 --> 00:09:34,380
当然，这个单文件不需要包含这个软件
运行所需求的所有东西


86
00:09:34,380 --> 00:09:40,230
application needs to run, but only those
parts that we cannot reasonably assume
AppImage除了目标的基础操作系统中包含的东西外
并不依赖其他东西运行


87
00:09:40,230 --> 00:09:46,890
这就意味着


88
00:09:46,890 --> 00:09:52,980
除了那些一般发行版都预装的外

89
00:09:52,980 --> 00:10:01,470
其实AppImage是包含所有需要组件的
另一个关于AppImage的核心理念是


90
00:10:01,470 --> 00:10:07,200 
我们不允许包含任何

91
00:10:07,200 --> 00:10:13,020
我们认为已经包含在系统里的组件
只要我们认为某些合适的依赖库

92
00:10:15,540 --> 00:10:20,550
已包含在主流发行版中，我们就不必包含在AppImage内。

93
00:10:20,550 --> 00:10:26,670
但是觉得异议的话

94
00:10:26,670 --> 00:10:35,130
那我们就会包含进去
还有一个打包AppImage的核心思想


95
00:10:35,130 --> 00:10:41,130
是分发给你的用户不需要任何中间人


96
00:10:41,130 --> 00:10:45,810
比如Repo那样的东西阻挡

97
00:10:45,810 --> 00:10:50,279
在作者跟用户间

98
00:10:50,279 --> 00:10:56,850
别的系统中也利用了这个成功的模式

99
00:10:56,850 --> 00:11:02,250
即使系统有一个应用商店
尽管你能自己判断 但我还是会说

100
00:11:02,250 --> 00:11:06,690
主要的模式不是应用的作者
和用户之间存在任何媒介

101
00:11:06,690 --> 00:11:11,610
最终，简单成为了核心思想

102
00:11:11,610 --> 00:11:16,920
为此，我们试图去掉所有复杂的东西

103
00:11:16,920 --> 00:11:26,910
并且达到最大化的精简 那什么是AppImage呢
AppImagea是我谈到过的单文件应用程序

104
00:11:26,910 --> 00:11:32,79
实际上你可以有一个应用的每一个版本的单文件

105
00:11:32,790 --> 00:11:39,060
并且他们也能够共存
应用的镜像包含两部分

106
00:11:39,060 --> 00:11:46,080
第一部分是一些少量的可执行头部

107
00:11:46,080 --> 00:11:52,560
第二部分包含应用的主体部分 现在
引导程序是一个常规的二进制文件

108
00:11:56,370 --> 00:12:04,350
一个Linux可执行的二进制文件
用来挂载磁盘镜像

109
00:12:04,350 --> 00:12:10,770
然后执行这个磁盘镜像 这个挂载是在
fuse系统上 这意味着

110
00:12:10,770 --> 00:12:18,120
你不需要用root权限挂载AppImage 

111
00:12:18,120 --> 00:12:24,660
这个磁盘镜像本身是一个常规的ISO文件
它同时也被压缩了 可以用普通 Linux

112
00:12:24,660 --> 00:12:29,580
内核的方法用loop参数挂载，这是每个Linux发行版
都拥有的一部分，如果你想深入查看磁盘镜像

113
00:12:29,580 --> 00:12:34,709
只需要用loop参数挂载。并且检查它包含的内容

114
00:12:38,520 --> 00:12:44,640
磁盘镜像包含了你的应用的有效荷载
你最好关心下他的依赖

115
00:12:44,640 --> 00:12:53,890
AppDir是应用的目录

116
00:12:53,890 --> 00:13:01,000
当然应用目录是一个文件系统树
它包含了应用和它所需要的依赖

117
00:13:01,000 --> 00:13:07,720
我们所假设基本系统的部分中

118
00:13:07,720 --> 00:13:13,750
不存在一个叫做AppRun的单文件和
主要入口点

119
00:13:13,750 --> 00:13:23,079
当你运行AppImage

120
00:13:23,079 --> 00:13:29,440
创建AppDir时你应该明白 AppDir必须

121
00:13:29,440 --> 00:13:35,230
没有任何依赖，它不能期望成为
你目标平台中所有系统或者是发行版的一部分

122
00:13:35,230 --> 00:13:42,880
最实际的做法是

123
00:13:42,880 --> 00:13:48,190
在一个比最老的目标平台还要老旧
的平台来编译你的应用

﻿124
00:13:50,175 --> 00:13:58,525
然后将所有目标系统中缺少的文件
打包到AppImage文件中

125
00:14:00,450 --> 00:14:02,550
还有一些进一步的想法

126
00:14:03,525 --> 00:14:05,262
比如软件的更新方式 

127
00:14:06,525 --> 00:14:12,925
让我们假设我们安装了一个约100兆
大小的每日构建版本的AppImage应用

128
00:14:13,300 --> 00:14:22,980
每天都需要要去下载那个100多兆
大的文件并不是一件令人愉快的事

129
00:14:23,850 --> 00:14:30,598
所以利用增量升级的方法 我们只需
下载应用中发生变化的部分

130
00:14:30,598 --> 00:14:33,198
在实际应用中,需要重新下载的部分不会很多

131
00:14:33,198 --> 00:14:35,924
我对一大批应用进行过这方面的测试 

132
00:14:36,975 --> 00:14:39,263
对很多应用而言，只需要下载差不多
约2兆大小的文件

133
00:14:39,263 --> 00:14:42,370
就可以完成从一个每日构建版本到另一个的升级

134
00:14:42,370 --> 00:14:44,250
这种方法在实际应用中切实有效 

135
00:14:44,575 --> 00:14:48,276
我在这里给出一个链接供您亲自尝试

136
00:14:48,925 --> 00:14:52,025
下一个想法是使用沙箱技术

137
00:14:52,800 --> 00:14:58,750
沙箱技术不仅让应用更易于运行
还让运行应用在某种程度上变得更加安全

138
00:14:58,750 --> 00:15:03,375
通过将应用限制在一个只读文件系统中

139
00:15:03,375 --> 00:15:03,399
它便不能进行一些恶意行为

140
00:15:03,399 --> 00:15:05,459
它便不能进行一些恶意行为

141
00:15:05,459 --> 00:15:09,050
 例如删除你的home目录下的文件,或者其他类似行为

142
00:15:09,725 --> 00:15:14,325
我已经针对这个想法进行了一些实验

143
00:15:14,950 --> 00:15:18,525
最后,我们也希望与构建系统有机结合

144
00:15:19,948 --> 00:15:29,625
使得制作AppImage最终和编译普通软件一样简单

145
00:15:29,901 --> 00:15:33,676
为了实现这个目标 我们计划将AppImageKit与构建系统结合起来

146
00:15:34,025 --> 00:15:38,250
不过现在我必须说 我并不是一个精通编译系统的人

147
00:15:38,250 --> 00:15:38,256
所以如果有人在这个领域有开发经验 请来联系我

148
00:15:38,256 --> 00:15:42,925
所以如果有人在这个领域有开发经验,请来联系我

149
00:15:42,925 --> 00:15:42,930
我们可以一起完成将AppImageKit与构建系统结合的任务

150
00:15:42,930 --> 00:15:48,950
我们可以一起完成将AppImageKit与构建系统结合的任务

151
00:15:50,675 --> 00:15:53,925
以上是我的想法

152
00:15:53,925 --> 00:15:53,938
正如我前面所说的

153
00:15:53,938 --> 00:15:56,325
正如我前面所说的

154
00:15:56,800 --> 00:15:58,562
十年多的时间,我一直在做这个项目

155
00:15:59,150 --> 00:16:00,375
那些反对意见又是怎样的呢？

156
00:16:00,375 --> 00:16:03,703
事实上,有各种各样的反对的声音混杂在一起 

157
00:16:03,703 --> 00:16:06,500
这里是一些典型的意见

158
00:16:07,900 --> 00:16:11,025
"这个工具的存在是多此一举" 

159
00:16:12,050 --> 00:16:18,350
这是经常从一些看不出AppImage作为对系统包管理器的补充的必要性的

160
00:16:18,350 --> 00:16:23,442
linux发行版用户那里听到的反对的声音

160
00:16:20,260 --> 00:16:30,610
添加到发行版软件包管理器 我们来看看另一个

161
00:16:30,610 --> 00:16:35,319
如果这个玩意儿是开源的 我们就不需要这个工具包来创建

162
00:16:35,319 --> 00:16:42,459
包或者传输需要的库 确实是这样 你可以试试

163
00:16:42,459 --> 00:16:47,319
下载喜欢的软件的最新版本 我们来试试Krita3.0

164
00:16:47,319 --> 00:16:53,380
前几天才发布的 你会发现 如果你用的是CentOS 6.0的话

165
00:16:53,380 --> 00:16:58,529
会很难用得上

166
00:17:00,000 --> 00:17:06,040
另一个是 这样解包的话将会是安全噩梦

167
00:17:06,040 --> 00:17:11,850
有两种情况 第一种是

168
00:17:11,849 --> 00:17:17,399
当我从原作者哪里下载些东西时

169
00:17:17,400 --> 00:17:22,650
我相信这个软件和他的作者 如果不是的话

170
00:17:22,650 --> 00:17:28,950
我应该先运行该软件 对我来说 我更喜欢先

171
00:17:28,950 --> 00:17:32,910
直接从源代码编译运行软件 相比于

172
00:17:32,910 --> 00:17:37,290
从那些中间人哪里获取 你永远不知道他们对原文件做了什么 不论那些

173
00:17:39,450 --> 00:17:46,530
是否经过原作者同意的更改 第二种争议是

174
00:17:46,530 --> 00:17:51,050
我们没有“沙盒” 但是像我之前说的

175
00:17:51,050 --> 00:17:56,970
运行AppImage的可选择沙盒环境正在实验当中

176
00:17:56,970 --> 00:18:05,880
比如说在一个只读的限制环境之类的 所以想得到反馈

177
00:18:05,880 --> 00:18:12,600
需要很长一段时间 我几乎实现了把这些软件打包到Linux的想法 我还觉得

178
00:18:17,250 --> 00:18:23,160
这跟文化很有关系 当OSX 10上还有

179
00:18:23,160 --> 00:18:28,530
苹果在好多年前就打包好的软件时

180
00:18:28,530 --> 00:18:32,400
看起来linux用户有些不同 他们居然不赞同这个点子

181
00:18:32,400 --> 00:18:41,220
直到AppImage的出现
Linus Torvalds还说过

182
00:18:41,220 --> 00:18:47,190
他试用了一会儿AppImage然后觉得

183
00:18:47,190 --> 00:18:52,260
这玩意儿超酷，进入屏幕下方的链接

184
00:18:52,260 --> 00:18:57,900
那里有很多的讨论 还有所有信息的来源及更多信息

﻿185
00:18:57,900 --> 00:19:07,500
linus是真的证实了AppImage和AppImagekit的理念 这真的很棒

186
00:19:09,475 --> 00:19:10,675
其他人也赞同这一点

187
00:19:10,675 --> 00:19:14,125
比如subsurface（一个潜水记录日志应用）项目目前的维护者

188
00:19:14,125 --> 00:19:17,606
他说AppImage确实非常非常有用

189
00:19:19,590 --> 00:19:25,149
从那开始很多开源软件开始采用AppImage

190
00:19:25,400 --> 00:19:26,525
例如krita（免费开源的绘图软件）

191
00:19:26,525 --> 00:19:28,700
现在在他们的下载页面提供AppImage版本

192
00:19:29,123 --> 00:19:33,700
就像他们给Windows和Mac上提供的一致

193
00:19:35,225 --> 00:19:40,775
还有scribus项目 一个开源电子杂志制作软件

194
00:19:40,775 --> 00:19:46,600
同样在下载页面为Linux提供了AppImage 甚至为候选版本提供了AppImage下载

195
00:19:47,900 --> 00:19:54,600
Musescore音乐软件现在不仅为64位系统提供AppImage

196
00:19:54,600 --> 00:19:59,969
而且也为32位系统提供AppImage 甚至为ARM系统提供

197
00:19:59,969 --> 00:20:03,675
所以你甚至可以在你的手机 平板电脑或者树莓派上运行它

198
00:20:06,825 --> 00:20:10,114
那么怎样才能制作一个AppImage呢

199
00:20:12,550 --> 00:20:15,359
它真的不是那么复杂

200
00:20:16,025 --> 00:20:21,549
在这里我展示了一个小小的helloworld示例 重新包装现有的二进制文件

201
00:20:21,549 --> 00:20:27,825
在这里我把下好的leafpad（linux下一款轻量级编辑器）的deb软件包

202
00:20:28,250 --> 00:20:32,014
转换成为了一个AppImage包

203
00:20:32,275 --> 00:20:39,350
我做的第一件事是建立一个leafpad应用程序目录

204
00:20:40,525 --> 00:20:47,049
然后下载deb软件包 接下来进入AppDir目录

205
00:20:48,450 --> 00:20:54,950
解压deb包 复制图标文件和桌面链接文件

206
00:20:54,950 --> 00:21:03,675
到AppDir的根目录之后从AppImagekit获取AppRun文件

207
00:21:04,025 --> 00:21:08,919
AppRun文件是进入AppDir的主要入口点

208
00:21:08,919 --> 00:21:15,149
我以前谈过这个 它基本上发挥了启动应用程序的全部魔力

209
00:21:15,800 --> 00:21:24,399
最后我退出AppDir目录 然后我使用AppImagetool将AppDir

210
00:21:24,399 --> 00:21:27,639
转换成AppImage 这真的很简单

211
00:21:27,639 --> 00:21:29,725
结果便是一个可以运行的AppImage 

212
00:21:30,450 --> 00:21:36,090
在这种情况下

213
00:21:36,090 --> 00:21:40,545
这些二进制文件来自更新的发行版

214
00:21:40,545 --> 00:21:49,100
所以在一个你能得到的最旧的发行版上编译二进制文件非常有用

215
00:21:51,750 --> 00:21:57,225
在现实世界中，你想做的可能不只是

﻿216
00:21:57,659 --> 00:21:59,850
重新打包已有的二进制软件

217
00:21:59,850 --> 00:22:03,659
但是在自己构建的时候

218
00:22:03,659 --> 00:22:05,359
最好使用一个成熟的发行版

219
00:22:06,250 --> 00:22:10,175
最好是你能够找到的最老的发行版本

220
00:22:10,175 --> 00:22:14,550
以便你能够找到一个现成的编译器和构建工具

221
00:22:15,300 --> 00:22:19,225
我已经成功在Centos 6上实现

222
00:22:19,950 --> 00:22:24,925
前提是你打包的应用没有硬编码路径

223
00:22:25,600 --> 00:22:32,075
除非你可以在源码甚至二进制文件上打上补丁

224
00:22:33,400 --> 00:22:37,150
剩下要做的就和前面我所说的一样了

225
00:22:37,700 --> 00:22:40,275
把你的应用转换成AppDir

226
00:22:40,700 --> 00:22:49,400
并且你应该把各个需要调用的库也打包进AppDir里面

227
00:22:49,400 --> 00:22:55,108
也就是说如果你的应用调用了一个非常新的库

228
00:22:55,525 --> 00:23:01,575
你必须把这个库包含到AppImage中

229
00:23:02,340 --> 00:23:06,925
最后当你成功构建出你的应用镜像 请在各个发行版进行测试

230
00:23:06,925 --> 00:23:11,460
不要忽略这重要的一步

231
00:23:11,460 --> 00:23:19,400
我有各种live版的Linux操作系统

232
00:23:19,400 --> 00:23:22,550
可以用于测试我打包的AppImage

233
00:23:26,000 --> 00:23:32,100
当你可以连续构建的时候 你会发现这是非常有趣的

234
00:23:32,825 --> 00:23:41,325
连续构建指的是每当有人提交了变更 你都可以自动化的构建你的软件

235
00:23:42,123 --> 00:23:51,907
如果你可以做到那样 那么你就可以在很短的时间内完成你的打包工作

236
00:23:51,907 --> 00:23:55,969
这将大大增加打包的效率

237
00:23:56,275 --> 00:24:00,225
想象一下这就像Git一样

238
00:24:03,125 --> 00:24:06,640
下面这就是我成功应用的一系列流程

239
00:24:06,640 --> 00:24:09,452
无论什么时候我把更新推送到github

240
00:24:09,800 --> 00:24:16,100
然后Travis CI这个在云端的持续构建系统就会取回包含Centos 6的

241
00:24:16,100 --> 00:24:19,000
打包系统的docker容器里的内容

242
00:24:19,000 --> 00:24:24,310
这个系统里面包含了所有预装的依赖

243
00:24:24,310 --> 00:24:28,569
然后在云端把应用打包成AppImage

244
00:24:28,850 --> 00:24:34,875
然后把它上传到BinTray

245
00:24:34,875 --> 00:24:36,610
BinTray是一个终端用户可以下载的网站

246
00:24:36,610 --> 00:24:44,856
我们可以把这个网址链接到AppImage上

247
00:24:49,030 --> 00:24:56,770
每当有人在github上推送提交后
都能得到一个新的可运行的二进制文件.

248
00:24:56,770 --> 00:25:05,890
你可以在https://github.com/probonopd/上查看这个过程

249
00:25:05,890 --> 00:25:13,450
然后你就能看到我之前描述的
有一些软件

250
00:25:13,450 --> 00:25:19,330
已经打包好了 比如MuseScore和Scribus
请随意将这套流程

251
00:25:21,550 --> 00:25:25,270
应用于其他构建系统或者其他基础服务
我很乐意

252
00:25:25,270 --> 00:25:31,990
更多人能接受并使用它
如果你对此感兴趣我们非常欢迎 那么如何为AppImage做贡献呢？

253
00:25:31,990 --> 00:25:36,100
首要途径就是大力宣传AppImage
让人们意识到

254
00:25:36,100 --> 00:25:40,900
这是一套行之有效的解决方案

255
00:25:40,900 --> 00:25:46,480
更好的办法是建议你喜欢的程序的

256
00:25:46,480 --> 00:25:52,900
上游社区讨论使用AppImage进行打包

257
00:25:52,900 --> 00:25:57,880
理想情况下社区可能会信心十足地直接采用AppImage打包

258
00:25:57,880 --> 00:26:02,440
甚至以后都这样打包发布
也有可能他们

259
00:26:02,440 --> 00:26:08,380
会在拿一些项目练手打包测试之后放弃发布打包后的成品

260
00:26:08,380 --> 00:26:12,820
那真是太遗憾了
本可以很容易地做出一个更适应未来的精品应用

261
00:26:16,630 --> 00:26:21,220
请向你最爱的上游软件社区建议
打包一个AppImage格式应用

262
00:26:21,220 --> 00:26:26,170
但请注意 测试仍是必要的

263
00:26:26,170 --> 00:26:31,570
请在各种主流发行版上进行调试
直至令人满意

264
00:26:34,780 --> 00:26:42,660
你才能把AppImage的包整合进主要的基础软件设施中

265
00:26:42,660 --> 00:26:49,090
对于你自己的资源控制管理来说
我之前给出的例子就是采用github或者

266
00:26:52,380 --> 00:27:01,180
Travis CI或者docker或者以二进制包的形式来适配你的打包流程

267
00:27:01,180 --> 00:27:05,650
最终你会为AppImage项目本身做出贡献
比如一个可以自动生成AppImage的工具集

268
00:27:05,650 --> 00:27:10,960
现在有一个很好的例子
就是AppImage更新工具

269
00:27:10,960 --> 00:27:14,350
还处在概念验证状态而且有点简陋和粗糙
在这方面我们急需更多的帮助

270
00:27:16,990 --> 00:27:23,710
当遇到疑问时
请立即在github提交issue 大概就这么多 非常感谢您的观看！

271
00:27:23,710 --> 00:27:36,630
翻译团队名单 策划/组织-小鸡 翻译-AliveGh0st/冷清°

